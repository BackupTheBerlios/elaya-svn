{
Elaya, the compiler for the elaya language
Copyright (C) 1999-2003  J.v.Iddekinge.
Web   : www.elaya.org

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
}

unit ExecObj;
interface
uses  classes,largenum,ddefinit,procs,frames,nconvert,types,error,elacons,progutil,vars, display,compbase,cmp_type,
	elatypes,pocobj,macobj,node,formbase,varbase,params,ndcreat,stdobj,asminfo,elacfg,confval,varuse;
	
type
	
	
	TDirectValueNode=class(TFormulaNode){TODO name is wrong}
	private
		voType : TType;
	protected
		property iType : TType read voType write voType;
	public
		property fType : TType read voType;
		function GetType : TType;override;
		constructor Create(ParType :TType);
	end;
	
	TReturnVarNode=class(TDirectValueNode)
	protected
		procedure Commonsetup;override;

	public
		function  Can(ParCan  : TCan_Types) : boolean;override;
		procedure PrintNode(ParDis:TDisplay);override;
		function CreateMac(ParOption : TMacCreateOption;ParCre : TSecCreator): TMacBase;override;
	end;
	
	TConstantValueNode=class(TDirectValueNode)
	private
		voValue : TValue;
		property  iValue : TValue read voValue write voValue;
	protected
		procedure   Commonsetup;override;

	public
		function    GetValue : TValue;override;
		function    IsConstant : boolean;override;
		procedure   PrintNode(ParDisplay : TDisplay);override;
		constructor Create(ParValue : TValue;ParType : TType);
		procedure   Clear;override;
		function    CreateMac(ParOption : TMacCreateOption;ParCre : TSecCreator):TMacBase;override;
		function    ConvertNodeType(ParType : TType;ParCre : TCreator;var ParNode:TFormulaNode):boolean;override;
		function    IsCompWithType(ParType :TType):boolean;override;
		function    Can(ParCan:TCan_Types):boolean;override;
	end;
	
	
	TPointerNode=class(TConstantNode)
	protected
		procedure  commonsetup;override;

	public
		constructor Create(parNum:TPointerCons);
		procedure  PrintNode(ParDis:TDisplay);override;
		destructor destroy;override;
	end;
	
	TOperNode=class(TFormulaNode)
	protected
		function CheckCOnvertNode(ParCre : TCreator;ParType :TType;var ParNode : TFormulaNode):boolean;
		function CheckCOnvertNode2(ParCre : TCreator;ParType :TType;var ParNode : TFormulaNode):boolean;

	public
		function  Can(ParCan:TCan_Types):boolean;override;
		procedure InitParts;override;
		function  CheckNode(ParNode:TFormulaNode):boolean;virtual;
		procedure GetOperStr(var ParOper:String);virtual;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function  AddNode(ParCre:TCreator;parNode:TNodeIdent):boolean;override;
		procedure PrintNode(ParDis:TDisplay);override;
		function  GetType:TType;override;
		function  CheckNodeIsSafe(ParNode : TNodeIdent) : boolean;override;
		procedure SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);override;
		procedure ValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);override;
		procedure Get2SubNode(var ParFirst,ParSecond:TFormulaNode);
		function CheckConvertTest(ParType1,ParType2 : TType) : boolean;virtual;
	end;
	
	TValueOperNode=class(TOperNode)
	public
		procedure SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);override;
	end;
	
	TArrayIndexNode=class(TValueOperNode)
	private
		voType:TType;
		voBase:TFormulaNode;
		property iType : TType read voType write voType;
		property iBase : TFormulaNode read voBase write voBase;
	protected
		procedure commonsetup;override;

	public
		function  Can(ParCan:TCan_Types):boolean;override;
		function  AddNode(ParCre:TCreator;ParNode:TNodeIdent):boolean;override;
		procedure SafeValidateNode(ParCre : TCreator;var ParNode:TNodeident);override;
		procedure PrintNode(ParDis:TDisplay);override;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function  GetType:TType;override;
		procedure SetBase(ParCre : TNDCreator;ParNode : TFormulaNode);
		procedure Clear;override;
		procedure ValidateAfter(ParCre : TCreator);override;
	end;
	
	TByPtrNode=class(TValueOperNode)
	private
		voExtraOffset :TOffset;
		property iExtraOffset : TOffset read voExtraOffset write voExtraOffset;
	protected
		procedure commonsetup;override;

	public
		property fExtraOffset : TOffset read voExtraOffset write voExtraOffset;
		
		
		function  Can(ParCan:TCan_Types):boolean;override;
		procedure SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
		function  GetType:TType;override;
		procedure GetOperStr(var ParOper:string);override;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function   IsOptUnsave:boolean;override;
	end;
	
	
	
	TBoolOperNode=class(TValueOperNode)
	private
		voBooleanType : TType;
	protected
		property iBooleanType : TType read voBooleanType write voBooleanType;
	public
		constructor Create(ParBooleanType:TType);
		function    GetType:TType;override;
		procedure   ValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
	end;
	
	TCompNode=class(TBoolOperNode)
	private
		voCompCode : TIdentCode;
		property iCompCode : TIdentCode read voCompCode write voCompCode;

	protected
		procedure   Commonsetup;override;

	public
		function	CreatePartSec(ParCre : TSecCreator;ParSecond : boolean): boolean;
		function    CreateSec(ParCre:TSecCreator):boolean;override;
		function    CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		constructor Create(ParCode : TIdentCode ;ParBooleantype:TType);
		procedure   GetOperStr(var parOper:String);override;
		procedure   ValidateAfter(ParCre : TCreator);override;
		procedure   InitParts;override;
		function    CheckConvertTest(ParType1,ParType2 : TType) : boolean;override;
		procedure   ValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
	end;
	
	
	
	TBetweenNode=class(TBoolOperNode)
	protected
		procedure Commonsetup;override;

	public
		function  CreateSec(PArCre:TSecCreator):boolean;override;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		procedure PrintNode(ParDis:TDisplay);override;
	end;
	
	
	TDualOperNode=class(TOperNode)
	public
		procedure SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
		function  GetReplace(ParCre:TCreator):TNodeIdent;override;
	end;
	
	TOrdDualOperNode=class(TDualOperNode)
	public
		procedure SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
	end;
	
	TMulNode=class(TOrdDualOperNode)
	protected
		procedure   commonsetup;override;

	public
		procedure   InitParts;override;
		procedure   GetOperStr(var ParOper:string);override;
	end;
	
	TShrNode=class(TOrdDualOperNode)
	protected
		procedure   commonsetup;override;

	public
		procedure   InitParts;override;
		procedure   GetOperStr(var ParOper:string);override;
	end;

	TShlNode=class(TOrdDualOperNode)
	protected
		procedure   commonsetup;override;

	public
		procedure   InitParts;override;
		procedure   GetOperStr(var ParOper:string);override;
	end;

	
	TDivNode=class(TOrdDualOperNode)
	protected
    		procedure   commonsetup;override;
	public
		procedure   InitParts;override;
		procedure   GetOperStr(var ParOper:string);override;
	end;
	
	TModNode=class(TOrdDualOperNode)
	protected
		procedure commonsetup;override;

	public
		procedure GetOperStr(var ParOper:string);override;
		procedure InitParts;override;
		
	end;
	
	
	
	TOrdOperNode=class(TValueOperNode)
	public
		procedure SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);override;
	end;
	
	
	TLoadNode=class(TOrdOperNode)
	protected
		procedure Commonsetup;override;

	public
		function  CheckNode(ParNode : TFormulaNode):boolean;override;
		procedure GetOperStr(var ParOper:string);override;
		function  CreateSec(ParCre:TSecCreator):boolean;override;
		procedure ValidateAfter(ParCre : TCreator);override;
		function CheckConvertTest(ParType1,ParType2 : TType) : boolean;override;
		function  SetVarUseItem(ParCre : TSecCreator;ParMode : TAccessMode;var ParUseList : TVarUseList;var ParItem : TVarUseItem) : TAccessStatus;override;
		procedure ValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);override;
	end;
	
	
	TNegNode=class(TOrdOperNode)
	protected
		procedure commonsetup;override;

	public
		function  GetReplace(ParCre:TCreator):TNodeIdent;override;
		function  AddNode(ParCre:TCreator;parNode:TNodeIdent):boolean;override;
		procedure GetOperStr(var ParOper:string);override;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
	end;
	
	
	TDotOper  =class(TOperNode)
	public
		
		voField : TFormulaNode;
	private
		property iField : TFormulaNode read voField write voField;
	protected
		procedure   commonsetup;override;
		procedure   Clear;override;

	public
		property    fField : TFormulaNode read voField;
		constructor Create(ParField : TFormulaNode);
		function    IsOptUnsave:boolean;override;
		procedure   GetOperStr(var ParOper:string);override;
		function    Can(parCan:TCan_Types):boolean;override;
		function    GetType:TType;override;
		function    CreateSec(ParCre:TSecCreator):boolean;override;
		function    CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		procedure   SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);override;
		procedure   InitDotFrame(ParCre :TSecCreator);override;
		procedure   DoneDotFrame;override;
		function 	CreateObjectPointerOfNode(ParCre : TCreator) : TFormulaNode;override;
		procedure Print(ParDis : TDisplay);override;
	end;
	
	TLogicNode=class(TValueOperNode)
	public
		function CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function CheckNode(ParNode:TFormulaNode):boolean;override;
	end;
	
	TNotNode=class(TLogicNode)
	protected
		procedure commonsetup;override;

	public
		procedure GetOperStr(var ParOper:string);override;
		procedure InitParts;override;
		function  CreateSec(ParCre:TSecCreator):boolean;override;
		procedure PrintNode(ParDis:TDisplay);override;
		function  CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
	end;
	
	TAndNode = class(TLogicNode)
	protected
		procedure commonsetup;override;

	public
		procedure GetOperStr(var ParOper:string);override;
		procedure InitParts;override;
		function  CreateSec(ParCre:TSecCreator):boolean;override;
	end;
	
	
	TOrNode= class(TLogicNode)
	protected
		procedure commonsetup;override;

	public
		procedure GetOperStr(var ParOper:string);override;
		procedure InitParts;override;
		function  CreateSec(ParCre:TSecCreator):boolean;override;
	end;
	
	TXorNode=class(TLogicNode)
	protected
		procedure commonsetup;override;

	public
		procedure GetOperStr(var ParOper:string);override;
		procedure InitParts;override;
		function  CreateSec(ParCre:TSecCreator):boolean;override;
		function  CreateMac(ParOpt:TMacCreateOption;parCre:TSecCreator):TMacBase;override;
	end;
	
	
	TExitNode=class(TNodeIdent)
	private
		voReturnType          : TType;
		voReturnInstruction   : TNodeIdent;
		property iReturnType  : TType            read voReturnType        write voReturnType;
		property iReturnInstruction : TNodeIDent read voReturnInstruction write voReturnInstruction;
	public
		
		constructor Create(ParReturnType : TType;ParReturnInstruction : TNodeIdent);
		function    CreateSec(ParCre : TSecCreator):boolean;override;
		procedure   PrintNode(ParDis : TDisplay);override;
		procedure   ValidateAfter(parCre : TCreator);override;
		procedure   Optimize(ParCre:TCreator);override;
		procedure   clear;override;
	end;
	
	TThenElseNode=class(TNodeIdent)
	private
		voThenElse:boolean;
		property iThenElse : boolean read voThenElse write voThenElse;
	public
		function  CreateSec(ParCre:TSecCreator):boolean;override;
		procedure print(ParDis:TDisplay);override;
		constructor Create(ParThenElse:boolean);
	end;
	
	TOperList=class(TFormulaList)
	private
		voPoc : TRefFormulaPoc;
	protected
		property    iPoc : TRefFormulaPoc read voPoc write voPoc;
		function    CreatePoc(ParCre : TSecCreator;ParMac1,ParMac2:TMacBase) : TMacBase;virtual;
	public
		property    fPoc : TRefFormulaPoc read voPoc write voPoc;
		
		function    HandleNode(ParCre:TSecCreator;ParNode:TNodeIdent):boolean;override;
		constructor Create(ParPoc : TRefFormulaPoc);
		function    CanOptimize1:boolean;virtual;
		procedure   CalculateOperator(ParCre : TCreator;var ParResult:TNumber;ParPos : cardinal;ParValue:TNumber);virtual;
		procedure   GetFirstValue(var ParValue : TNumber);virtual;
		function    AddOptimizedValue(ParCre : TCreator;ParValue : TNumber):boolean;virtual;
		function    Optimize1(ParCre:TCreator):boolean;override;
		function    CreateMac(ParOption:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function    CheckOptimize1Method:boolean;
	end;
	
	TShrNodeList=class(TOperList);


	TMulNodeList=class(TOperList)
	public
		function  CanOptimize1:boolean;override;
		procedure GetFirstValue(var ParValue : TNumber);override;
		function  AddOptimizedValue(ParCre : TCreator;ParValue : TNumber):boolean;override;
		procedure CalculateOperator(ParCre :TCreator;var ParResult:TNumber;ParPos : cardinal;ParValue:TNumber);override;
		function  CanOptimizeCpx:boolean;override;
	end;
	
	
	
	TLogicList=class(TOperList)
	private
		voWhen  : boolean;
		property iWhen : boolean read voWhen write voWhen;
	public
		constructor Create(ParPoc : TRefFormulaPoc;ParWhen:boolean);
		function    HandleNode(ParCre:TSecCreator;ParNode:TNodeIdent):boolean;override;
	end;
	
	TMacOption=class(TOperNode)
	private
		voDoneType  : boolean;
		voType      : TType;
		voMacOption : TMacCreateOption;

		property iType : TType read voType write voType;
		property iMacOption : TMacCreateOption read voMacOption write voMacOption;
		property iDoneType  : boolean read voDoneType write voDoneType;
	protected
		procedure   commonsetup;override;

	public
		property fMacOption : TMacCreateOption read voMacOption;
		property fDoneTYpe  : boolean read voDoneType;

		procedure GetOperStr(var ParOper:string);override;
		function    Can(ParCan:TCan_Types):boolean;override;
		function    CheckNode(ParNode:TFormulaNode):boolean;override;
		function    AddNode(ParCre:TCreator;ParNode:TNodeIdent):boolean;override;
		function    GetType:TType;override;
		constructor Create(ParOption:TMacCreateOption);
		function    CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		destructor  destroy;override;
		function    GetValue:TValue;override;
		function    IsConstant : boolean;override;
	end;
	

	TPointerOfNode=class(TOperNode)
	private
		voType      : TType;
		voExpression: TFormulaNode;
		property iType      : TType        read voType       write voType;
		property iExpression: TFormulaNode read voExpression write voExpression;
	protected
		procedure commonsetup;override;
		procedure Clear;override;
	public

		procedure GetOperStr(var ParOper:string);override;
		function    Can(ParCan:TCan_Types):boolean;override;
		function    CheckNode(ParNode:TFormulaNode):boolean;override;
		function    GetType:TType;override;
		constructor Create(ParNode : TFormulaNode;ParType :TType);
		function    CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
	end;
	
	TTypeNode=class(TOperNode)
	private
		voType : TType;
	protected
		property iType : TType read voType write voType;
		procedure   Commonsetup;override;

	public
		function   IsOptUnsave:boolean;override;
		constructor Create(parTYpe:TType);
		function    Can(ParCan:TCan_Types):boolean;override;
		function    CheckNode(parNode:TFormulaNode):boolean;override;
		procedure   ValidateAfter(ParCre : TCreator);override;
		function    CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		function    GetType:TType;override;
		procedure   PrintNode(ParDis:TDIsplay);override;
	end;
	
	TClassTypeNode=class(TTypeNode)
	public
		procedure InitDotFrame(ParCre : TSecCreator);override;
		procedure DoneDotFrame;override;
	end;
	
	TLoopCBNode=class(TNodeIdent)
	private
		voBreakLabel    : TLabelPoc;
		voContinueLabel : TLabelPoc;
		property iBreakLabel    : TLabelPoc read voBreakLabel    write voBreakLabel;
		property iContinueLabel : TLabelPoc read voContinueLabel write voContinueLabel;
	protected
		function   OptimizeThisNode(ParCre : TCreator;ParNode : TFormulaNode):TFormulaNode;
		procedure Commonsetup;override;

	public

		function  GetBreakLabel : TLabelPoc;
		function  GetContinueLabel :TLabelPoc;
	end;
	
	
	TCountNode=class(TLoopCBNode)
	private
		voUp    : boolean;
		voCount : TFormulaNode;
		voBegin : TFormulaNode;
		voEnd   : TFormulaNode;
		voStep  : TFormulaNode;
		voEndCondition : TFormulaNode;
	protected
		property iUp    : boolean      read voUp    write voUp;
		property iCount : TFormulaNode read voCount write voCount;
		property iBegin : TFormulaNode read voBegin write voBegin;
		property iEnd   : TFormulaNode read voEnd   write voEnd;
		property iStep  : TFormulaNode read voStep  write voStep;
		property iEndCondition : TFormulaNode read voEndCondition write voEndCondition;
	protected
		procedure CheckNodeByType(ParCre : TCreator;ParType :TType ;ParCheck : TFormulaNode);
		procedure  commonsetup;override;

	public

		procedure  SetCount(ParCre:TNDCreator;parNode:TFormulaNode);
		procedure  SetBegin(ParCre:TNDCreator;ParNode:TFormulaNode);
		procedure  SetEnd(ParCre:TNDCreator;ParNode:TFormulaNode);
		procedure  SetStep(ParCre:TNDCreator;ParNode:TFormulaNode);
		procedure  SetEndCondition(ParCre : TNDCreator;ParNode : TFormulaNode);
		procedure  Setup(parUp:boolean);
		procedure  print(ParDis:TDisplay);override;
		function   CreateSec(parcre:TSecCreator):boolean;override;
		destructor destroy;override;
		procedure  Optimize(ParCre : TCreator);override;
		procedure ValidateAfter(ParCre : TCreator);override;
	end;
	
	TConditionNode=class(TLoopCBNode)
	private
		voCond           : TFormulaNode;
		property iCond   : TFormulaNode read voCond write voCond;
	protected
		procedure  commonsetup;override;

	public
		property fCond : TFormulaNode read voCond;
		procedure  SetCond(ParCre :TNDCreator;ParCond:TFormulaNode);
		destructor destroy;override;
		procedure  Optimize(ParCre : TCreator);override;
		procedure  ValidateAfter(ParCre  : TCreator);override;
		function  SetVarUseItem(ParCre : TSecCreator;ParMode : TAccessMode;var ParUseList : TVarUseList;var ParItem : TVarUseItem) : TAccessStatus;override;
	end;
	
	TWhileNode=class(TConditionNode)
	public
		function    CreateSec(ParCre:TSecCreator):boolean;override;
		procedure   PrintNode(ParDis:TDisplay);override;
	end;
	
	
	
	TRepeatNode=class(TConditionNode)
	public
		procedure   PrintNode(ParDis:TDisplay);override;
		function    CreateSec(ParCre:TSecCreator):boolean;override;
	end;
	
	TForNode = class(TConditionNode)
	private
		voEnd   :TFormulaNode;
		property   iEnd : TFormulaNode read voEnd write voEnd;
	protected
		procedure  commonsetup;override;

	public
		
		property   fEnd : TFormulaNode read voEnd;
		procedure  SetEnd(ParCre:TNDCreator;ParNode:TFormulaNode);
		procedure  SetBegin(ParCre:TNDCreator;parNode:TFormulaNode);
		destructor destroy;override;
		procedure  print(ParDis:TDisplay);override;
		function   CreateSec(ParCre:TSecCreator):boolean;override;
		procedure   Optimize(ParCre :TCreator);override;
		procedure  ValidateAfter(ParCre  : TCreator);override;
		
	end;
	
	TAsmNode=class(TNodeIdent)
	private
		voText : pointer;
		voSIze : cardinal;
		procedure SetText(ParSize:cardinal;ParText:Pointer);
		function  GetText:Pointer;
		function  GetSize:cardinal;
	protected
		procedure   CommonSetup; override;
		procedure   clear;override;

	public
		constructor Create(ParSize : TSize;ParText:pointer);
		procedure   ResetText;
		procedure   print(ParDis:TDisplay);override;
		function    CreateSec(ParCre:TSecCreator):boolean;override;
	end;
	
	TRefLoopFlowNode = class of TLoopFlowNode;
	TLoopFlowNode=class(TNodeIdent)
	private
		voLCBNode	: TLoopCBNode;
		property iLCBNode:TLoopCbNOde read voLCBNode write voLCBNode;
	protected
		property fLCBNode:TLoopCBNode read voLCBNode write voLCBNode;
	public
		constructor Create(ParNode:TLoopCbNode);
		function GetJumpLabel:TLabelPoc;virtual;
		function CreateSec(parCre:TSecCreator):boolean;override;
	end;
	
	
	TBreakNode = class(TLoopFlowNode)
	protected
		procedure Commonsetup;override;

	public
		function  GetJumpLabel:TLabelPoc;override;
		procedure Print(ParDIs:TDisplay);override;
	end;
	
	TContinueNode = class(TLoopFlowNode)
	protected
		procedure Commonsetup;override;

	public
		function  GetJumpLabel:TLabelPoc;override;
		procedure Print(ParDIs:TDisplay);override;
		
	end;
	
	
	TLabelNode=class(TFormulaNode)
	private
		voType      : TType;
		voDefinition: TDefinition;
		property iType      : TType   read voTYpe      write voType;
		property iDefinition: TDefinition read voDefinition write voDefinition;
	protected
    	procedure Commonsetup;override;
	public
		function   Can(ParCan : TCan_Types):boolean;override;
		procedure print(ParDis:TDisplay);override;
		constructor create(ParDef : TDefinition;ParType : TType);
		function   CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;override;
		procedure  GetName(var ParName : string);
		function   GetType : TType;override;
	end;
	
	
	TStringNode=class(TConstantNode)
	protected
		procedure   Commonsetup;override;

	public
		constructor Create(ParNum:TStringCons);
		procedure   PrintNode(ParDis:TDisplay);override;
		function    ConvertNodeType(ParType : TTYpe;ParCre : TCreator;var ParNode:TFormulaNode):boolean;override;
		function    IsCompWithType(ParType :TType):boolean;override;
		function	CanWriteTo(ParExact : boolean;ParType : TType):boolean;override;
		function    CreateMac(ParOpt : TMacCreateOption;ParSec :TSecCreator):TMacBase;override;
	end;
	
	TLeaveNode=class(TNodeIdent)
	public
		function  CreateSec(ParCre:TSecCreator):boolean;override;
		procedure   PrintNode(ParDis:TDisplay);override;

	end;

implementation
uses cblkbase;

{---( TLEaveNode )---------------------------------------------------------------}

function  TLeaveNode.CreateSec(ParCre:TSecCreator):boolean;
var
	vlLabel : TLabelPoc;
	vlJmp   : TJumpPoc;
begin
	vlLabel := ParCre.NewLeaveLabel;
	vlJmp := TJumpPoc.Create(vlLabel);
	ParCre.AddSec(vlJmp);
	exit(false);
end;

procedure TLeaveNOde.PrintNode(ParDis:TDisplay);
begin
	ParDis.Write('<leave>');
	ParDis.Writenl('</lave>');
end;


{---( TStringNode )---------------------------------------------------------------}
function  TStringNode.CreateMac(ParOpt : TMacCreateOption;ParSec :TSecCreator):TMacBase;
var
	vlText : string;
begin
    TStringCons(fVariable).GetString.GetString(vlText);
	ParSec.AddStringConstant(vlText);
	exit(inherited CreateMac(ParOpt,ParSec));
end;

function TStringNode.CanWriteTo(ParExact : boolean;ParTYpe : TType):boolean;
var
	vlType : TType;
	vlType2: TType;
begin
	if ParType <> nil then begin
		vlType := ParType.GetOrgType;
		if(vlType  is TCharType) and (vlType.fSize= 1) and (TStringCons(fVariable).GetString.fLength = 1) then exit(true);
		if vlType is TAsciizType then exit(true);
		if (vlType is TPtrType) then begin
			vlType2 := TPtrType(vlType).fTYpe;
			vlType2 := vlType2.GetOrgType;
			if (vlType2 <> nil) and (vlType2 is TAsciizType) then exit(true);
		end;
		exit(inherited CanWriteTo(ParExact,ParType));
	end;
	exit(false);
end;

function  TStringNode.IsCompWithType(ParType :TType):boolean;
var
	vlType : TTYpe;
	vlType2 : TType;
begin
	if (ParType = Nil) or (GetType = nil) then exit(false);
	vlType := ParType.GetOrgType;
	if vlType = nil then exit(false);
	if (vlType is TCharType) and (ParType.fSize=1) and (TStringCons(fVariable).GetString.fLength=1) then exit(true);
	if (vlType is TAsciizType) then exit(true);
	if (vlType is TPtrType) then begin
		vlType2 := TPtrType(vlType).fTYpe;
		vlType2 := vlType2.GetOrgType;
		if (vlType2 <> nil) and (vlType2 is TAsciizType) then exit(true);
	end;
	exit(GetType.IsDirectComp(ParType));
end;

function TStringNode.ConvertNodeType(ParType : TTYpe;ParCre : TCreator;var ParNode:TFormulaNode):boolean;
var
	vlType       : TType;
	vlType2      : TType;
	
function CreateAsciizNode : TFormulaNode;
var
	vlNode       : TStringNode;
	vlArr        : TArrayIndexNode;
	vlVOid       : TTypeNode;
	vlVoidType   : TType;
	
begin
	vlNode := TStringNode.Create(TStringCons(fVariable));
	vlArr  := TArrayIndexNode.Create;
	vlArr.SetBase(TNDCreator(ParCre),vlNode);
	vlArr.AddNode(ParCre,TNDCreator(ParCre).CreateIntNodeLong(1));
	vlVoidType := TNDCReator(ParCre).GetCheckDefaultType(DT_Void,0,false,'void');
	vlVoid     := TTypeNode.Create(vlVoidType);
	vlVOid.AddNode(ParCre,vlArr);
	exit(vlVoid);
end;

begin
	if ParType <> nil then begin
		vlType := ParType.GetOrgType;
		if (vlType is TCharType) and (vlType.fSize = 1) then begin
			if TStringCons(fVariablE).GetString.fLength = 1 then begin
				ParNode := TConstantValueNode.Create(TStringCons(fVariable).getString.NewString,ParType);
				exit(true);
			end;
		end else
		if (vlType is TAsciizType) then begin
			
			ParNode := (CreateAsciizNode);
			exit(true);
			
		end else if (vlType is TPtrType) then begin
			
			vlType2 := TPtrType(vlType).fType;
			if vlType2.GetOrgType is TAsciizType then begin
				ParNode :=CreateAsciizNode.CreateObjectPointerOfNode(ParCre);
				exit(true);
			end;
		end;
	end;
	ParNode := nil;
	exit(false);
end;

constructor TStringNode.Create(ParNum:TStringCons);
begin
	inherited Create(TVarBase(ParNum));
end;

procedure   TStringNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_StringNode;
end;

procedure   TStringNode.PrintNode(PArDIs:TDisplay);
begin
	ParDis.print(['<value>',#39]);
	ParDis.WritePst(TStringCons(fVariable).GetString);
	ParDis.Print([#39,'<value>']);
end;


{----( TLabelNode )--------------------------------------------------------}

procedure TLabelNode.GetName(var ParName : string);
begin
	iDefinition.GetMangledName(ParName);
end;

function TLabelNode.Can(ParCan : TCan_Types):boolean;
begin
	exit(inherited Can(ParCan - [CAN_Pointer]));
end;


function TLabelNode.GetType:TType;
begin
	exit(iType);
end;

procedure   TLabelNode.Commonsetup;
begin
	inherited commonsetup;
	iIdentCode := (IC_LabelNode);
end;

procedure   TLabelNode.print(ParDis:TDisplay);
begin
	iDefinition.PrintName(ParDis);
end;

constructor TLabelNode.create(ParDef : TDefinition;ParType : TType);

begin
	inherited create;
	iType      := ParType;
	iDefinition:= ParDef;
end;



function  TLabelNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlName : string;
	vlMac  : TMemOfsMac;
	vlMac2 : TMacBase;
begin
	if ParOpt = MCO_Result then begin
		GetName(vlName);
		vlMac2 := TLabelMac.Create(vlName,GetTypeSize);
		ParCre.AddObject(vlMac2);
	end else if ParOpt in [mco_ValuePointer,MCO_ObjectPointer] then begin
		vlMac := TMemOfsMac.Create;
		vlMac.SetSourceMac(CreateMac(MCO_Result,ParCre));
		vlMac2 := vlMac;
		ParCre.AddObject(vlMac2);
	end else begin
		vlMac2 := inherited CreateMac(ParOpt,ParCre);
	end;
	exit(vlMac2);
end;

{----( TBreakNode )---------------------------------------------------------}


procedure TBreakNode.Print(parDis:TDisplay);
begin
	ParDis.Writenl('<Break></break>');
end;

procedure TBreakNode.Commonsetup;
begin
	inherited Commonsetup;
	iIdentCode := IC_BreakNode;
end;

function  TBreakNode.GetJumpLabel:TLabelPoc;
begin
	if fLCBNode = nil then exit(nil);
	exit(fLCBNode.GetBreakLabel);
end;


{----( TContinueNode )---------------------------------------------------------}

procedure TContinueNode.PRint(parDis:TDisplay);
begin
	ParDis.write('<Continue></continue>');
end;

procedure TContinueNode.Commonsetup;
begin
	inherited Commonsetup;
	iIdentCode := (IC_BreakNode);
end;

function  TContinueNode.GetJumpLabel:TLabelPoc;
begin
	if fLCBNode = nil then exit(nil);
	exit(fLCBNode.GetContinueLabel);
end;


{----( TLoopFlowNode )-------------------------------------------------------}


constructor TLoopFlowNode.Create(ParNode:TLoopCbNode);
begin
	iLcbNode := ParNode;
	inherited create;
end;

function TLoopFlowNode.GetJumpLabel:TLabelPoc;
begin              ;
	exit(nil);
end;

function TLoopFlowNode.CreateSec(ParCre:TSecCreator):boolean;
var vlLabel : TLabelPoc;
	vlJump  : TJumpPoc;
begin
	CreateSec := false;
	vlLabel := GetJumpLabel;
	if vlLabel <> nil then begin
		vlJump := TJumpPoc.Create(vlLabel);
		ParCre.AddSec(vlJump);
	end else begin
		fatal(Fat_Cant_Det_Jump_Label,'TLoopFlowNode.CreateSec');
	end;
end;

{----( TLoopCBNode )---------------------------------------------------------}

function TLoopCBNode.OptimizeThisNode(ParCre : TCreator;ParNode : TFormulaNode) : TFormulaNode;
var vlRepl : TFormulaNode;
	
begin
	if ParNode = nil then exit(nil);
	ParNode.OptimizeForm(ParCre,vlRepl);
	if vlRepl <> nil then begin
		ParNode.Destroy;
	end else begin
		vlRepl := ParNode;
	end;
	exit(vlRepl);
end;

function  TLoopCBNode.GetBreakLabel : TLabelPoc;
begin
	if iBreakLabel = nil then iBreakLabel := TLabelPoc.Create;
	exit(iBreakLabel);
end;

function  TLoopCbNode.GetContinueLabel :TLabelPoc;
begin
	if iContinueLabel = nil then iContinueLabel := TLabelPoc.Create;
	exit(iContinueLabel);
end;

procedure TLoopCbNode.Commonsetup;
begin
	inherited Commonsetup;
	iBreakLabel    := nil;
	iContinueLabel := nil;
end;

{----( TAsmNode )-------------------------------------------------------------}

function  TAsmNode.CreateSec(ParCre:TSecCreator):boolean;
begin
	CreateSec := false;
	ParCre.addSec((TAsmPoc.create(GetSize,GetText)));
	ResetText;
end;


procedure TAsmNode.Print(parDis:TDisplay);
begin
	ParDis.writeNl('<ASM>');
	ParDis.SetLeftMargin(4);
	PARDIS.WriteRaw(GetText,GetSize);
	ParDis.SetLeftMargin(-4);
	ParDis.writeNl('<END>');
end;

constructor TAsmNode.Create(ParSize : TSize;ParText:pointer);
begin
	inherited Create;
	SetText(parSize,ParText);
end;

procedure TAsmNode.clear;
begin
	inherited Clear;
	SetText(0,nil);
end;

procedure TAsmNode.ResetText;
begin
	voText := nil;
end;


procedure TAsmNode.SetText(ParSize:Cardinal;ParText:Pointer);
begin
	if GetText <> nil then freemem(GetText,GetSize);
	voText := parText;
	voSize := PArSize;
	
end;

function  TAsmNode.GetText:Pointer;
begin
	GetText := voText;
end;

function  TAsmNode.GetSize:cardinal;
begin
	GetSize := voSize;
end;

procedure TAsmNode.commonsetup;
begin
	inherited Commonsetup;
	voText     := nil;
	voSize     := 0 ;
	iIdentcode := (IC_AsmNode);
end;



{---( TForNode )-----------------------------------------------------------}


procedure TForNode.ValidateAfter(ParCre  : TCreator);
begin
	inherited ValidateAfter(ParCre);
	if iEnd<> nil then iEnd.ValidateAfter(ParCre);
end;


procedure TForNode.Optimize(ParCre :TCreator);
begin
	inherited Optimize(parCre);
	iEnd := OptimizeThisNode(ParCre,iEnd);
end;


procedure  TForNode.SetBegin(ParCre:TNDCreator;ParNode:TFormulaNode);
begin
	SetCond(ParCre,ParNode);
end;

procedure  TForNode.SetEnd(ParCre:TNDCreator;ParNode:TFormulaNode);
begin
	if iEnd <> nil then iEnd.Destroy;
	iEnd := ParNode;
	if ParNode <> nil then begin;
		if not ParNode.Can([Can_Read]) then ParCre.SemError(Err_Cant_Read_From_Expr);
		if not ParNode.IsLikeType(TBooleanType) then ParCre.SemError(Err_Wrong_Type);
	end;
end;

procedure  TForNode.Commonsetup;
begin
	inherited commonsetup;
	iEnd := nil;
end;

destructor TForNode.Destroy;
begin
	inherited Destroy;
	if iEnd <> nil then iEnd.Destroy;
end;


procedure TForNode.Print(ParDis:TDisplay);
begin
	ParDis.Writenl('<for>');
    ParDis.Write('<while>');
	PrintIdent(ParDis,fCond);ParDis.nl;
	ParDis.Write('</while>');
	ParDis.WriteNl('<until>');
	PrintIdent(ParDis,iEnd);ParDis.nl;
	ParDis.WriteNl('</until>');
	ParDis.Write('<code>');
	iParts.Print(ParDis);ParDis.nl;
	ParDis.WriteNl('</code>');
	ParDis.WriteNl('</for>');
end;

function  TForNode.CreateSec(ParCre:TSecCreator):boolean;
var vlPrvTrue  : TLabelPoc;
	vlPrvFalse : TLabelPoc;
	vlLabTrue  : TLabelPoc;
	vlLabFalse : TLabelPoc;
	vlLabBegin : TLabelPoc;
	vlJmp      : TJumpPoc;
begin
	vlLabTrue  := GetContinueLabel;
	vlLabFalse := GetBreakLabel;
	vlLabBegin := TLabelPoc.Create;
	vlJmp      := TJumpPoc.Create(vlLabBegin);
	ParCre.AddSec(vlJmp);
	ParCre.AddSec(vlLabTrue);
	iParts.CreateSec(ParCre);
	vlPrvTrue  := ParCre.SetLabelTrue(vlLabFalse);
	vlPrvFalse := ParCre.SetLabelFalse(vlLabBegin);
	iEnd.CreateSec(parCre);
	ParCre.AddSec(vlLabBegin);
	ParCre.SetLabelTrue(vlLabTrue);
	ParCre.SetLabelFalse(vlLabFalse);
	fCond.CreateSec(ParCre);
	ParCre.AddSec(vlLabFalse);
	ParCre.SetLabelTrue(vlPrvTrue);
	ParCre.SetLabelFalse(vlPrvFalse);
	CreateSec := false;
end;


{-----( TCountNode )-------------------------------------------------------}

procedure TCountNode.CheckNodeByType(ParCre : TCreator;ParTYpe : TType ;ParCheck : TFormulaNode);
begin
	if (ParType <> nil) and (ParCheck <>nil) then begin
		ParCheck.ValidateAfter(ParCre);
		ParCheck.ValidateConstant(ParCre,@ParType.ValidateConstant);
	end;
end;


procedure TCountNode.ValidateAfter(ParCre : TCreator);
var
	vlType :TType;
begin
	inherited ValidateAfter(parCre);
	if iCount <> nil then begin
		iCount.ValidateAfter(ParCre);
		vlType := iCount.GetType;
		CheckNodeByType(ParCre,vlType,iBegin);
		CheckNodeByType(ParCre,vlType,iEnd);
	end;
end;

procedure  TCountNode.Optimize(ParCre : TCreator);
begin
	inherited Optimize(parCre);
	iBegin := OptimizeThisNode(ParCre,iBegin);
	if iEnd <> nil then iEnd   := OptimizeThisNode(ParCre,iEnd);
	iCount := OptimizeThisNode(ParCre,iCount);
	if iEndCondition <> nil then iEndCOndition := OptimizeThisNode(ParCre,iEndCondition);
end;


procedure  TCountNode.SetEndCondition(ParCre : TNDCreator;ParNode : TFormulaNode);
begin
	if iEndCOndition <> nil then iEndCondition.Destroy;
	iEndCondition := ParNode;
	if ParNode <> nil then begin
		if not(ParNode.Can([Can_Read])) then ParCre.SemError(Err_Cant_Read_From_Expr);
		if ParNode.GetTypeDefault <> DT_Boolean then ParCre.SemError(Err_Not_Boolean_Type);
	end;
end;

procedure TCountNode.SetCount(ParCre:TNDCreator;ParNode:TFormulaNode);
begin
	if iCount <> nil then iCount.Destroy;
	iCount := ParNode;
	if ParNode <> nil then begin
		if not ParNode.Can([CAn_Write]) then ParCre.SemError(Err_Cant_Write_To_Item);
		if not ParNode.IsCompByIdentCode(IC_Number) then ParCre.SemError(Err_Wrong_Type);
	end;
end;

procedure TCountNOde.SetBegin(ParCre:TNDCreator;ParNode:TFormulaNode);
begin
	if iBegin <> nil then iBegin.Destroy;
	iBegin := ParNode;
	if ParNode <> nil then begin
		if not ParNode.Can([CAn_Read])                 then ParCre.SemError(Err_Cant_Read_From_Expr);
		if not ParNode.IsCompByIdentCode(IC_Number) then ParCre.SemError(Err_Wrong_Type);
	end;
end;

procedure TCountNode.SetEnd(ParCre:TNDCreator;PArNode:TFormulaNode);
begin
	if iEnd <> nil then iEnd.Destroy;
	iEnd := ParNode;
	if parNode <> nil then begin
		if not ParNode.Can([CAn_Read])              then ParCre.SemError(Err_Cant_Read_From_Expr);
		if not ParNode.IsCompByIdentCode(IC_Number) then ParCre.SemError(Err_Wrong_Type);
	end;
end;

procedure TCountNode.SetStep(ParCre:TNDCreator;ParNode:TFormulaNode);
begin
	if iStep <> nil then iStep.Destroy;
	iStep := ParNode;
	if ParNode <> nil then begin
		if not ParNode.Can([Can_Read])              then ParCre.SemError(Err_Cant_Read_From_Expr);
		if not ParNode.IsCompByIdentCode(IC_Number) then ParCre.SemError(Err_Wrong_Type);
	end;
end;


procedure TCountNode.SetUp(ParUp:boolean);
begin
	iUp := ParUp;
end;


procedure TCountNode.Commonsetup;
begin
	inherited Commonsetup;
	iCount := nil;
	iBegin := nil;
	iEnd   := nil;
	iStep  := nil;
	iUp    := false;
end;

destructor TCountNode.Destroy;
begin
	inherited Destroy;
	if iCount <> nil then iCount.Destroy;
	if iBegin <> nil then iBegin.Destroy;
	if iEnd   <> nil then iEnd.Destroy;
	if iStep  <> nil then iStep.Destroy;
	if iEndCondition <> nil then iEndCondition.Destroy;
end;

procedure TCountNode.Print(ParDis:TDisplay);
begin
	ParDis.WriteNl('<count>');
	ParDis.Write('<counter>');PrintiDent(ParDis,iCount);ParDis.WriteNl('</counter>');
	ParDis.Write('<begin>');PrintIdent(ParDis,iBegin);ParDis.WriteNl('</begin>');
	ParDis.Write('<direction>');
	if iUp then begin
		ParDis.Write('UP')
	end else begin
		ParDis.Write('DOWNTO');
	end;
	ParDis.WriteNl('</direction>');
	if iEnd <> nil then begin
		ParDis.write('<end>');PrintiDent(ParDis,iEnd);ParDis.WriteNl('</end>');
	end;
	if iEndCondition <> nil then begin
		ParDis.Write('<until>');PrintIdent(ParDis,iEndCondition);ParDIs.WriteNl('</until>');
	end;
	ParDis.WriteNl('<code>');
	iParts.Print(ParDis);
	ParDis.WriteNl('</code>');
end;

function  TCountNode.CreateSec(parcre:TSecCreator):boolean;
var vlLod     :TLoadFor;
	vlCOunt   :TMacBase;
	vlBegin   :TMacBase;
	vlEnd     :TMacBase;
	vlLab     :TLabelPoc;
	vlFlag    :TMacBase;
	vlJmp 	  :TJumpPoc;
	vlCode    :TIdentCode;
	vlAddFor  :TFormulaPoc;
	vlPrvTrue : TLabelPoc;
	vlPrvFalse : TLabelPoc;
	vlTrue     : TLabelPoc;
	vlTestFirst : boolean; {Test first and then decrement}
	vlValue     : TValue;
	vlCheckLab  : TLabelPoc;
begin
	vlCount := iCount.CreateMac(MCO_Result,ParCre);
	vlBegin := iBegin.CreateMac(MCO_Result,ParCre);
	vlLod := (TLoadFor.create);
	vlLod.SetVar(0,vlCount);
	vlLod.SetVar(1,vlBegin);
	ParCre.AddSec(vlLod);
	vlLab := ParCre.AddLabel;
	if iEndCondition <>nil then begin
		vlTrue := ParCre.CreateLabel;
		vlPrvTrue := ParCre.SetLabelTrue(GetBreakLabel);
		vlPrvFalse := ParCre.SetLabelFalse(vlTrue);
		iEndCondition.CreateSec(ParCre);
		ParCre.SetLabelTrue(vlPrvTrue);
		ParCre.SetLabelFalse(vlPrvFalse);
		ParCre.AddSec(vltrue);
	end;
	iParts.CreateSec(ParCre);
	ParCre.AddSec(GetContinueLabel);
	vlAddFor := TIncDecFor.Create(iUp);
	vlAddFor.SetVar(0,iCount.CreateMac(MCO_Result,ParCre));
	vlAddFor.SetVar(1,iStep.CreateMac(MCO_Result,ParCre));
    vlTestFirst := true;

	if iEnd <>nil then begin
		vlValue := iEnd.GetValue;
		if vlValue <> nil then begin
			if iUp then begin
				vlTestFirst := iCount.IsMaximum(vlValue);
			end else begin
				vlTestFirst := iCount.IsMinimum(vlValue);
			end;
			vlValue.Destroy;
		end;
	end;

	if not vlTestFirst then PArCre.AddSec(vlAddFor);
	if iEnd <>nil then begin
		if vlTestFirst then begin
			vlCode := IC_Eq;
			vlCheckLab := GetBreakLabel;
		end else begin
			vlCode := IC_LowerEq;
			if not iUp then vlCode := IC_BiggerEq;
			vlCheckLab := vlLab;
		end;
		vlEnd  := iEnd.CreateMac(MCO_Result,ParCre);
		vlFlag := ParCre.MakeCompPoc(iCount.CreateMac(MCO_Result,ParCre),vlEnd,vlCOde);
		vlJmp := TCondJumpPoc.create(true,vlFlag,vlCheckLab);
	end else begin
		vlJmp := TJumpPoc.Create(vlLab);
	end;

	ParCre.AddSec(vlJmp);
	if vlTestFirst then begin
		PArCre.AddSec(vlAddFor);
		vlJmp := TJumpPoc.Create(vlLab);
		ParCre.AddSec(vlJmp);
	end;
	ParCre.AddSec(GetBreakLabel);
	exit( false);
end;

{---(TArrayIndexNode )---------------------------------------------------------}


procedure TArrayIndexNode.Clear;
begin
	inherited Clear;
	if iBase <> nil then iBase.Destroy;
end;

procedure TArrayIndexNode.SetBase(ParCre : TNDCreator;ParNode : TFormulaNode);
var vlType : TType;
	vlErr  : boolean;
begin
	if ParNode= nil then exit;
	if iBase <> nil then iBase.Destroy;
	iBase := ParNode;
	vlType := ParNode.GetType;
	iType := vlType;
	vlErr := false;
	if vlType <>nil then begin
		vlErr :=not( vlType.Can([Can_Index]));
	end else begin
		vlErr := true;
	end;
	if vlErr then  TNDCreator(ParCre).SemError(err_Cant_Array_Index_type);
	
end;

function  TArrayIndexNode.Can(ParCan:TCan_Types):boolean;
var
	vlCan : TCan_Types;
begin
	vlCan := ParCan * [Can_Type,Can_Size,Can_Dot];
	if vlCan <> [] then begin
		if (iType  <> nil) then begin
			if not iType.Can(vlCan) then exit(false);
		end;
		ParCan := ParCan - vlCan;
	end;
	if iBase <> nil then begin
		exit(iBase.Can(ParCan));
	end else begin
		exit(false);
	end;
end;

procedure TArrayIndexNode.commonsetup;
begin
	inherited Commonsetup;
	iType := nil;
	iBase := nil;
	iCOmplexity := CPX_Array;
end;

procedure  TArrayIndexNode.SafeValidateNode(ParCre : TCreator;var ParNode:TNodeIdent);
begin
	inherited SafeValidateNode(ParCre,ParNode);
	if not TFormulaNode(ParNode).can([can_read]) then TNDCreator(ParCre).AddNodeError(ParNode,Err_Cant_Read_From_Expr,'');
	if not TFormulaNode(ParNode).IsCompByIdentCode(IC_Number) then  TNDCreator(ParCre).AddNodeError(ParNode,Err_Integer_Type_Expr_Exp,'');
end;


function  TArrayIndexnode.AddNode(ParCre:TCreator;ParNode:TNodeIdent):boolean;
var vlType    : TType;
begin
	Inherited AddNode(ParCre,ParNode);
	if IsLikeType(TArrayType) or IsLikeType(TStringBase) then begin
		vlType := GetOrgType;
		iType := TSecType(vlType).fType;
	end else begin
		TNDCreator(ParCre).SemError(Err_Too_Many_Index_Expr);
	end;
	AddNode := false;
end;

procedure TArrayIndexNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.WriteNl('<arrayindex>');
	ParDis.writeNl('<base>');
	PrintIdent(ParDis,iBase);
	ParDis.Writenl('</base><index>');
	iParts.Print(ParDis);
	ParDis.Write('</index></arrayindex>');
end;


function  TArrayIndexNode.GetType:TType;
begin
	GetType := iType;
end;

{TODO Remove IsLike ,orgtype @TArrayType(vlType).validateIndex}
procedure TArrayIndexNode.ValidateAfter(ParCre : TCreator);
var
	vlFirst   : TFormulaNode;
	vlCurrent : TFormulaNode;
	vlType    : TType;
begin
	inherited ValidateAfter(ParCre);
	if iBase = nil then exit;
	iBase.ValidateAfter(ParCre);
	vlFirst   := IBase;
	vlCurrent := TFormulaNode(GetPartByNum(1));
	vlType := vlFirst.GetType;
	if vlType <> nil then vlType :=vlType.GetOrgType;
	if vlFirst.IsLikeType(TArrayType) then begin
		while (vlType <> nil) and (vlCurrent <> nil) do begin
			if not(vlType.IsLike(TArrayType)) then break;
			vlCurrent.ValidateConstant(ParCre,@TArrayType(vlType).ValidateIndex);
			vlCurrent :=  TFormulaNode(vlCurrent.fNxt);
			vlType := TArrayType(vlType).GetOrgSecType;
		end;
	end else  begin
		if (vlCurrent <> nil) and (vlType <> nil) then begin
			if vlType is TStringBase then vlCurrent.ValidateConstant(ParCre,@TStringBase(vlType).ValidateIndex);
		end;
	end;
end;


function TArrayIndexNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var
	vlFirst  : TFormulaNode;
	vlPtr    : TMacBase;
	vlOut    : TMacBase;
	vlNode   : TFormulaNode;
	vlMin    : TArrayIndex;
	vlMAc    : TMacBase;
	vlSize   : TSize;
	vlDim    : TLargeNumber;
	vlNumOfs : TLargeNumber;
	vlCurrent: TArrayType;
	vlLi     : TLargeNumber;
	vlBaseType :TType;
begin
	if ParOpt=MCO_Size then exit( inherited CreateMac(MCO_Size,ParCre));
	vlFirst  := iBase;
	LoadLOng(vlNumOfs, 0);
	vlBaseType    := TArrayType(iBase.GetORGType);
	if vlBaseType = nil then exit;
	if iBase.IsLikeType(TArrayType) then begin
		vlNode    := TFormulaNode(GetPartByNum(1));
		vlSize    := 0;
		vlOut     := nil;
		vlCurrent := TArrayType(vlBaseType);
		while vlNode <> nil do begin
			vlMin := vlCurrent.fLo;
			vlDim := vlCurrent.fHi;
			LargeSub(vlDim,vlMin);
			{Num out of range wrong =>Offset out of range?}
			if LargeAddInt(vlDIm,1)     then ParCre.AddNodeError(vlNode,Err_Num_Out_Of_range,'');
			if LargeMul(vlNumOfs,vlDim) then ParCre.AddNodeError(vlNode,Err_Num_Out_Of_range,'');
			if  (vlOut <> nil)          then vlOut := ParCre.MakeMulPoc(vlOut,vlDim);
			vlMac := vlNode.CreateMac(MCO_Result,ParCre);
			if vlMac is TNumberMac then begin
				if LargeAdd(vlNumOfs ,TNumberMac(vlMac).fInt) then ParCre.AddNodeError(vlNode,Err_Num_Out_Of_range,'3');
			end else begin
				if vlOut <> nil then  vlOut := ParCre.MakeAddPoc(vlOut,vlMac)
								else  vlOut := vlMac;
			end;
			LargeSub(vlNumOFs,vlMin);
			vlNode := TFormulaNode(vlNode.fNxt);
			if vlCurrent.IsLike(TArrayType) then vlCurrent := TArrayType(vlCurrent.GetOrgSecType);
		end;
	end else begin
		vlOut   := TFormulaNode(GetPartByNum(1)).CreateMac(MCO_Result,ParCre);
		if (vlOut is TNumberMac) then begin
			vlNumOfs :=TNumberMac( vlOut).fInt;;
			vlOut := nil;
		end;
	end;
	if iType <> nil then begin
		vlSize := GetTypeSize;
		LoadLong(vlLi,vlSize);
		if LargeMul(vlNumOfs,vlLi) then ParCre.AddNodeError(vlFirst,Err_Num_out_of_Range,'');
		if(vlOut <>nil) and (vlSize <> 1) then begin
			vlMac := PArCre.CreateNumberMac(GetAssemblerInfo.GetSystemSize,false,vlLi);
			vlOut := ParCre.MakeMulPoc(vlOut,vlMac);
		end;
	end;
	if vlBaseType is TStringBase then begin
		if LargeAddInt(vlNumOfs, TStringBase(vlBaseType).GetFirstOffset) then ParCre.AddNodeError(vlNode,Err_Num_Out_Of_range,'4');
		LargeSubLong(vlNumOfs,GetTypeSize);
	end;
	if (vlOut = nil) and (ParOpt in [MCO_ValuePointer,MCO_ObjectPointer]) then begin
		vlMac := vlFirst.CreateMac(MCO_Result,ParCre);
		vlMac.SetSize(GetTypeSize);
		vlMac.SetSign(iType.GetSign);
		vlMac.AddExtraOffset(LargeToLongInt(vlNumOfs));
		vlOut := TMemOfsMac.Create;
		TMemOfsMac(vlOut).SetSourceMac(vlMac);
		ParCre.AddObject(vlOut);
	end else if (vlOut = nil) and (ParOpt=MCO_Result) then begin
		vlOut := vlFirst.CreateMac(MCO_Result,ParCre);
		vlOut.SetSize(GetTypeSize);
		vlOut.SetSign(iType.GetSign);
		vlOut.AddExtraOffset(LargeToLongInt(vlNumOfs));
	end else begin
		vlPtr := vlFirst.CreateMac(MCO_ValuePointer,ParCre);
		if vlOut <> nil then 	vlPtr := ParCre.MakeAddPoc(vlOut,vlPtr);
		if ParOpt=MCO_Result then begin
			vlOut := TByPointerMac.create(GetTypeSize,GetType.GetSign,vlPtr);
			ParCre.AddObject(vlOut);
			TByPointerMac(vlOut).AddExtraOffset(LargeToLongint(vlNumOfs));
		end else begin
			vlOut := ParCre.MakeAddPoc(vlPtr,LargeToLongint(vlNumOfs));
		end;
	end;
	exit(vlOut);
end;


{---( TClassTypeNode )------------------------------------------------------------}

procedure TClassTypeNode.InitDotFrame(ParCre : TSecCreator);
var
	vlType : TTYpe;
begin
	if not iParts.IsEmpty then begin
		inherited InitDotFrame(ParCre);
	end else begin
		vlType := GetType;
		TClassType(vlType).InitClassDotFrame(ParCre,fContext);
	end;
end;

procedure TClassTypeNode.DoneDotFrame;
var
	vlType : TType;
begin
	if not iParts.IsEmpty then begin
		inherited DoneDotFrame;
	end else begin
		vlType := GetType;
		TClassType(vlType).DoneClassDotFrame;
	end;
end;



{---(TTypeNode )------------------------------------------------------------------}


procedure TTypeNode.PrintNode(ParDis:TDIsplay);
begin
	ParDis.Write('<typeuse>');
    ParDis.Write('<type>');
	if GetType <> nil then begin
		GetType.PrintName(ParDis)
	end else begin
		ParDis.Write('$unkown');
	end;
	ParDis.Write('</type>');
	ParDis.Write('<expression>');
	iParts.Print(ParDis);
	ParDis.Write('</expression>');
    ParDis.Write('</typeuse>');
end;

function TTypeNode.Can(ParCan:TCan_Types):boolean;
var vlNode:TFormulaNode;
begin
	
	vlNode := TFormulaNode(GetPartByNum(1));
	if CAN_Dot in ParCan then begin
		if (GetType <> nil) and (GetType.Can([Can_Type])) then ParCan := ParCan - [Can_Dot];
	end;
	if vlNode = nil then begin
		Can    := (ParCan - [Can_Size,Can_Type] = []);
	end else begin
		Can := vlNode.Can(ParCan);
	end;
end;

function    TTypeNode.GetType:TType;
begin
	exit(iType);
end;

function    TTypeNode.CheckNode(parNode:TFormulaNode):boolean;
begin
	exit(false);
end;


procedure TTypeNode.ValidateAfter(ParCre : TCreator);
var

	vlFirst : TFormulaNode;
	vlExtra : string;
begin
	inherited ValidateAfter(ParCre);
	vlFirst := TFormulaNode(GetPartByNum(1));
	if vlFirst <> nil then begin
		if not vlFirst.Can([Can_Read])  then TNDCreator(ParCre).AddNodeError(vlFirst,Err_Cant_Read_From_Expr,'');
		if iType <> nil then begin
			if not  vlFirst.CanCastTo(GetType) then begin
				vlFirst.GetTypeName(vlExtra);
				vlExtra := vlExtra +' to ' + iType.GetErrorName;
				TNDCreator(ParCre).ErrorText(Err_Cant_Cast_To_This_Type,vlExtra);
			end;
		end;
	end;
end;

constructor TTypeNode.Create(parTYpe:TType);
begin
	inherited Create;
	iType := ParType;
end;

function  TTypeNode.IsOptUnsave:boolean;
var
	vlNode : TFormulaNode;
begin
	vlNode := TFormulaNode(GetPartByNum(1));
	if vlNode <> nil then begin
		exit(vlNode.IsOptUnsave);
	end else begin
		exit(False);
	end;
end;

function    TTypeNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlNode:TFormulaNode;
	vlMac : TMacBase;
	vlLd  : TLoadFor;
	vlMac2: TMacBase;
	vlLi  : TLargeNumber;
	vlMask: cardinal;
	vlSize :TSize;
begin
	vlNode := TFormulaNode(GetPartByNum(1));
	if (vlNode = nil) or (ParOpt=MCO_Size) then begin
		if ParOpt = MCO_SIZE then begin
			LoadLOng(vlLi,GetTypeSize);
			CreateMac := ParCre.CreateNumberMac(0,false,vlLi)
		end else begin
			fatal(FAT_Cant_Create_Mac_type,'');
		end;
	end else begin
		vlSize := GetTypeSize;
		vlMac := vlNode.CreateMac(ParOpt,parCre);
		if ParOpt=MCO_Result then begin
			{Todo: "is TNumberMac" A terr hack, this avoids TResultmac for number
			because extra offset doesn't work on TResultmac}
			if (vlMac is TNumberMac) then begin
				vlLi := TNumberMac(vlMac).fInt;
           		if not(GetTypeSign) and (LargeCompareInt(vlLi,0) = LC_Lower) then begin
					LargeAddLong(vlLi,1);
					LargeNot(vlLi);
				end;
				vlMask := ((1 shl (vlSize *8-1)) shl 1) -1;
				 {TODO: SHould be in Largenum unit something like LargeMask()}
				vlLi.vrNumber := vlLi.vrNUmber and vlMask;
				TNumberMac(vlMac).fInt := vlLi;
				vlMac.SetSize(vlSize);
			end else if  (vlMac.fSize >= GetTypeSize) or (vlMac.fSize = 0) then begin
				vlMac.SetSize(GetTypeSize);
			end else if vlMac.fSize < GetTypeSize then begin
				vlMac2 := TResultMac.Create(GetTypeSize,GetType.GetSign);
				ParCre.AddObject(vlMac2);
				vlLd   := TLoadFor.Create;
				vlLd.SetVar(0,vlMac2);
				vlLd.SetVar(1,vlMac);
				ParCre.AddSec(vlLd);
				vlMac := vlMac2;
			end;
			vlMac.SetSign(GetTypeSign);
		end;
		CreateMac := vlMac;
	end;
end;

procedure   TTypeNode.COmmonSetup;
begin
	inherited commonSetup;
	iType := nil;
	iIdentCode := (IC_TypeNode);
	iComplexity := CPX_Constant;{Should set to subnode complexity}
end;


{---( TMacOption )----------------------------------------------------------------}


function   TMacOption.Can(ParCan:TCan_Types):boolean;
begin
	Can := false;
	case fMacoption of
	MCO_Size 		   			  : Can := (ParCan - [CAN_Read]) = [];
	MCO_ValuePointer,MCO_ObjectPointer : Can := (ParCan - [CAN_Size , Can_Read]) = [];
end;
end;


procedure   TMacOption.CommonSetup;
begin
	inherited CommonSetup;
	iDoneType := false;
	iType     := nil;
	iCOmplexity := CPX_Constant;
end;

procedure TMacOption.GetOperStr(var ParOper:string);
begin
	case fMacOption of
	MCO_SIZE          : ParOper := 'SIZEOF';
	MCO_ObjectPointer : ParOper := 'OBJECT POINTER';
	MCO_ValuePointer  : ParOper := 'VALUE POINTER';
	else
end;
end;


function    TMacOption.GetType:TType;
begin
	exit( iType);
end;

function  TMacOption.CheckNode(ParNode:TFormulaNode):boolean;
begin
	exit( false);
end;

function  TMacOption.IsConstant : boolean;
begin
	exit(fMacOption = MCO_Size);
end;

function  TMacOption.GetValue:TValue;
var
	vlNode : TFormulaNode;
begin
	if fMacOption=MCO_Size then begin
		vlNode := TFormulaNode(GetPartByNum(1));
		if vlNode <> nil then begin
			exit(TLongint.Create(vlNode.GetSize));
		end;
	end;
	exit(nil);
end;


function  TMacOption.AddNode(ParCre:TCreator;ParNode:TNodeIdent):boolean;
var vlType  : TType;
	vlError : TErrorType;
	vlName  : string;
begin
	vlError := Err_No_Error;
	if ParNode = nil then exit(false);
	if (not iParts.isEmpty) then begin
		vlError := Err_int_Too_many_Nodes;
	end else begin
		vlType := nil;
		case fMacOption of
		MCO_Size:begin
			if not TFormulaNode(ParNode).Can([Can_Size]) then TNDCreator(ParCre).SemError(Err_Cant_Determine_Size);
			vlType := TNDCreator(PArCre).GetDefaultIDent(DT_Number,GetAssemblerInfo.GetSystemSize,false);
			iDoneType := false;
			iType     := vlType;
			if vlType = nil then vlError := Err_Cant_Find_type;
			end;
		MCO_ValuePointer:begin
			if ParNode is TCallNode then begin
				if TCallNode(ParNode).fParCnt <> 0 then TNDCreator(ParCre).SemError(Err_No_Parameters_Expected);
				if TCallNode(ParNode).IsOverloaded  then TNDCreator(ParCre).SemError(Err_Cant_Adr_Overl);
				vlType := TRoutineType.create(false,TCallNode(ParNode).fRoutineItem,false);
				TCallNode(ParNode).GetNameStr(vlName);
				vlType.SetText('Ptr to '+vlName);
			end else begin
				vlType := TFormulaNode(ParNode).GetType;
				if not TFormulaNode(ParNode).Can([CAN_Pointer]) then TNDCreator(ParCre).SemError(Err_Cant_Get_Expr_Pointer);
				if vlType = nil then begin
					vlName  := 'Unkown Type';
				end else begin
					vlType.GetTextStr(vlName);
					vlName := 'Ptr '+vlName;
				end;
				vlType := TPtrType.create(vlType,false);
				vlType.SetText(vlName);
			end;
			iDoneType := true;
			iType := vlType;			
		end;
		else vlError := Err_Int_Invalid_Mac_Opt;
	end;
end;
if vlError <> Err_No_Error then TNDCreator(ParCre).SemError(vlError);
AddNode := inherited AddNode(PArCre,ParNode);
end;



constructor TMacOption.Create(ParOption:TMacCreateOption);
begin
	iMacOption := ParOption;
	inherited Create;
end;

function    TMacOption.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var
	vlmac : TMacBase;
begin
	vlMac :=nil;
	case ParOpt of
		MCO_Result : vlMac := TFormulaNode(GetPartByNum(1)).Createmac(fMacOption,ParCre);
		MCO_SIze   : vlMac := inherited CreateMac(MCO_Size,ParCre);
		else begin
			Fatal(Fat_Invalid_Mac_Number,['option=',cardinal(ParOpt)]);
		end;
	end;
	exit(vlMac);

end;


destructor  TMacOption.Destroy;
begin
	inherited Destroy;
	if iDoneType then iType.Destroy;
end;


{---( TPointerOfNode )----------------------------------------------------------------}


function   TPointerOfNode.Can(ParCan:TCan_Types):boolean;
begin
	 Can := (ParCan - [CAN_Size , Can_Read]) = [];
end;


procedure   TPointerOfNode.CommonSetup;
begin
	inherited CommonSetup;
	iCOmplexity := CPX_Constant;

{TODO :identcode}
end;

procedure TPointerOfNode.GetOperStr(var ParOper:string);
begin
	ParOper := 'OBJECT POINTER';
end;


function    TPointerOfNode.GetType:TType;
begin
	exit( iType);
end;

function  TPointerOfNode.CheckNode(ParNode:TFormulaNode):boolean;
begin
	exit( false);
end;



constructor TPointerOfNode.Create(ParNode : TFormulaNode;ParType :TType);
begin
	iExpression := ParNode;
	iType := ParType;
	inherited Create;
end;

function    TPointerOfNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
begin
	exit(iExpression.Createmac(MCO_ObjectPOinter,ParCre));
end;


procedure TPointerOfNode.Clear;
begin
	inherited Clear;
	iExpression.Destroy;
	iType.Destroy;
end;

{--( TDirectValueNode )-------------------------------------------------------------}


function TDirectValueNode.GetType : TType;
begin
	exit(iType);
end;

constructor TDirectValueNode.Create(ParType :TType);
begin
	inherited Create;
	iType := ParType;
end;


{---( TReturnVarNode )---------------------------------------------------------------}


function  TReturnVarNode.Can(ParCan  : TCan_Types):boolean;
begin
	exit(ParCan - [CAN_Read,Can_Size,Can_Pointer,Can_Write]= []);
end;


procedure TReturnVarNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.Write('$returnvar');
end;


procedure TReturnVarNode.Commonsetup;
begin
	inherited Commonsetup;
	iCOmplexity := (CPX_ReturnVar);
end;



function TReturnVarNode.CreateMac(ParOption : TMacCreateOption;ParCre : TSecCreator): TMacBase;
var
	vlMac : TMacBase;
begin
	if ParOption = MCO_Result then begin
		vlMac := TOutputMac.create(fType.fSize,fType.GetSign);
		ParCre.AddObject(vlMac);
	end else begin
		vlMac := inherited CreateMac(ParOption,ParCre);
	end;
	exit(vlMac);
end;

{---( TConstantValueNode )-----------------------------------------------------------}

function  TConstantValueNode.IsConstant : boolean;
begin
	exit(true);
end;

procedure TConstantValueNode.Commonsetup;
begin
	inherited Commonsetup;
	iComplexity := CPX_COnstant;
end;

function  TConstantValueNode.Can(ParCan:TCan_Types):boolean;
begin
	exit(inherited Can(ParCan));
end;


function  TConstantValueNode.IsCompWithType(ParType :TType):boolean;
begin
	if iValue <> nil then begin
		if (iValue is TString) and ((ParType is TStringBase) or (ParType is TCharType))then exit(true);
	end;
	exit(inherited IsCompWithType(ParType));
end;

function  TConstantValueNode.ConvertNodeType(ParType : TType;ParCre : TCreator;var ParNode:TFormulaNode):boolean;
var
	vlVal : TNumber;
	vlType : TType;
begin
	if iValue <> nil then begin
		vlType := ParType.GetOrgType;
		if ((iValue is TCharValue) or (iValue is TString)) and (ParType.IsLike(TStringBase) or ParType.IsLike(TCharType)
			or ((vlType.IsLike(TPtrType) and (TPtrType(vlType).fType.IsLIke(TAsciizType)))))  then begin
			iType := ParType;
			ParNode := nil;
			exit(true);
		end else if (iValue is TPointer) and (ParType.IsLike(TRoutineType)) then begin
			vlType := ParType.GetOrgType;
			if TRoutineType(vlType).fOfObject then begin
                iValue.GetAsNumber(vlVal);
				if LargeCompareLong(vlVal,0)=LC_Equal then begin
					ParNode := TConstantValueNode.Create(iValue.Clone,ParType);
					exit(True);
				end;
			end;
		end;
	end;
	ParNode := nil;
	exit(false);
end;



function    TConstantValueNode.GetValue : TValue;
begin
	GetValue := iValue.clone;
end;

procedure   TConstantValueNode.PrintNode(ParDisplay : TDisplay);
begin
	ParDisplay.write('<value>');
	if iValue = nil then begin
		ParDisplay.Write('nil')
	end else begin
		 ParDisplay.Print([iValue]);
	end;
	ParDisplay.write('</value>');
end;

constructor TConstantValueNode.Create(ParValue : TValue;ParType : TType);
begin
	inherited Create(ParType);
	iValue := ParValue;
end;

procedure   TConstantValueNode.Clear;
begin
	inherited Clear;
	if iValue <> nil then iValue.Destroy;
end;

function   TConstantValueNode.CreateMac(ParOption : TMacCreateOption;ParCre : TSecCreator):TMacBase;
begin
	exit( fType.CreateConstantMac(ParOption,ParCre,iValue));
end;


{-----( TDotNode )-------------------------------------------}


procedure TDotOper.Print(ParDis : TDisplay);
begin
    ParDis.WriteNl('<dot>');
	ParDis.WriteNl('<record>');
	iParts.Print(ParDis);
	ParDis.nl;
	ParDis.WriteNl('</record><field>');
	if iField<> nil then iField.Print(ParDis);
	ParDis.nl;
	ParDis.Write('</field></dot>');
end;

	function TDotOper.CreateObjectPointerOfNode(ParCre : TCreator) : TFormulaNode;
	var
		vlType     : TType;
		vlName     : string;
		vlNode     : TFormulaNode;
		vlRoutine  : TRoutine;
	begin
		vlNode := TFormulaNode(GetPartByNum(1));
		if (vlNode <> nil) and (vlNode.Can([Can_Read])) then begin
			if (iField is TCallNode) then begin
				vlRoutine := TCallNode(iField).fRoutineItem;
				if vlRoutine.IsOverloaded  then TNDCreator(ParCre).AddNodeError(self,Err_Cant_Adr_Overl,'');
				vlType := TRoutineType.create(false,vlRoutine,true);
				vlRoutine.GetTextStr(vlName);
				vlType.SetText('Ptr to '+vlName);
				exit(TPointerOfNode.Create(self,vlType));
			end;
		end;
		exit(inherited CreateObjectPointerOfNode(ParCre));
	end;


procedure TDotOper.InitDotFrame(ParCre :TSecCreator);
var
	vlNode : TFormulaNode;
begin
	vlNode := TFormulaNode(GetPartByNum(1));
	if vlNode <> nil then vlNode.InitDotFrame(ParCre);
	iField.InitDotFrame(ParCre);
end;

procedure TDotOper.DoneDotFrame;
var
	vlNOde : TFormulaNode;
begin
	iField.DoneDotFrame;
	vlNode := TFormulaNode(GetPartByNum(1));
	if vlNode <> nil then vlNode.DoneDotFrame;
end;

procedure TDotOper.Clear;
begin
	inherited Clear;
	if iField <> nil then iField.Destroy;
end;

constructor TDotOper.Create(ParField : TFormulaNode);
begin
	inherited Create;
	iField := ParField;
end;

function TDotOper.GetType:TType;
begin
	if iField <> Nil then begin
		exit(iField.GetType);
	end else begin
		exit(nil);
	end;
end;

function TDotOper.Can(ParCan:TCan_Types):boolean;
var
	vlNode : TFormulaNode;
begin
	vlNode := TFormulaNode(GetPartByNum(1));
	if iField <> nil then begin
		if CAN_Execute in ParCan then begin
			if iField.Can([CAN_Execute]) then ParCan := ParCan - [Can_Execute]
		end;
		
		if CAN_Read in PArCan then begin
			if iField is TConstantNode then ParCan := ParCan - [Can_Read] else{TODO why?}
			if (iField is TTypeNode) and (iField.Can([Can_Read])) then ParCan := ParCan - [Can_Read] else
			if  iField.Can([Can_Execute,Can_Read]) then ParCan := ParCan - [Can_Read] else
			if (vlNode <> nil) and (vlNode.Can([Can_Read])) and (iField.Can([Can_Read])) then ParCan := ParCan - [Can_read];
		end;
		if (Can_Size in ParCan)  then begin
			if iField.Can([Can_Size]) then ParCan := ParCan - [Can_Size];
		end;
		if Can_Write in ParCan then begin
            if iField.Can([Can_Write]) then begin
				if (vlNode.Can([Can_Write])) or (iFIeld is TTypeNode)  then ParCan := ParCan - [Can_Write]
			end;
		end;
		if Can_Dot in ParCan then begin
			if iField.Can([Can_Dot]) then ParCan := ParCan - [Can_Dot];
		end;
		if Can_Pointer in ParCan then begin
			if iField.Can([Can_Pointer]) and (vlNode <> nil) and (vlNode.Can([Can_Pointer])) then ParCan := ParCan - [Can_Pointer];
		end;
		if Can_Type in ParCan then begin
			if iField.Can([Can_Type]) then ParCan := ParCan - [Can_Type];
		end;
	end;
	exit(ParCan = []);
end;


procedure TDotOper.SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
var vlType : TType;
begin
	if GetPartByNum(1) = nil then begin
		vlType := TFormulaNode(ParNode).GetType;
		{Hack to avoid constructor use with object
		 because constructor methods from object from virtual nested type can't be used yet.
		 In that situation the compiler failes with a context error
		}
		if iField <> nil then begin
			if (ParNode <> nil) and (iField is TCallNode) then begin
				if not TFormulaNode(ParNode).Can([Can_Type]) then begin
					if TCallNode(iField).fRoutineItem is TConstructor then TNDCreator(ParCre).SemError(Err_Cant_Use_Const_From_Obj);
				end;
			end;
		end;
		if (vlType = nil) or not(vlType.Can([CAN_DOT])) then TNDCreator(PArCre).SemError(Err_Cant_Use_Dot_Oper);
	end else begin
		TNDCreator(ParCre).SemError(Err_Invalid_Operation);
	end;
end;


procedure TDotOper.GetOperStr(var ParOper:String);
begin
	ParOper := 'DOT';
end;

procedure TDotOper.Commonsetup;
begin
	inherited CommonSetup;
	iIdentCOde := IC_DotNode;
	iComplexity := CPX_dot;
end;

function TDotOper.IsOptUnsave:boolean;
var
	vlForm : TFormulaNode;
begin
	vlForm := TFormulaNode(GetPartByNum(1));
	if (vlForm <> nil) then begin
		exit(vlForm.IsOptUnSave);
	end else begin
		exit(false);
	end;
end;

function TDotOper.CreateSec(ParCre:TSecCreator):boolean;
var
	vlCurrent : TFormulaNode;
begin
	vlCurrent := TFormulaNode(GetPartByNum(1));
	vlCurrent.InitDotFrame(ParCre);
	iField.CreateSec(ParCre);
	vlCurrent.DoneDotFrame;
	exit(false);
end;

function TDotOper.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlCurrent : TFormulaNode;
	vlMac     : TMacBase;
begin
	vlCurrent := TFormulaNode(GetPartByNum(1));
	vlMac := nil;
	if(vlCurrent <> nil) then begin
		case ParOpt of
			MCO_Result,MCO_ValuePointer,MCO_ObjectPointer:begin
				vlCurrent.InitDotFrame(ParCre);
				if (ParOpt = MCO_ObjectPointer) and (iField is TCallNode) then begin
					vlMac := TCallNode(iField).CreateDotMac(ParOpt,vlCurrent.CreateMac(MCO_Result,ParCre),ParCre);
				end else begin
					vlMac := iField.CreateMac(ParOpt,ParCre);
				end;
				vlCurrent.DoneDotFrame;
			end else begin
				vlMac := inherited CreateMac(ParOpt,ParCre);
			end;
		end;
	end;
	exit(vlMac);
end;


{-----( TOperList )------------------------------------------}

function TOperList.CheckOptimize1Method:boolean;
var vlCurrent : TFormulaNode;
	vlFirst   : boolean;
begin
	vlCurrent := TFormulaNode(fStart);
	vlFirst   := false;;
	while (vlCurrent <> nil) do begin
		if vlCurrent.IsConstant then begin
			if vlFirst then begin
				exit(true);
			end;
			vlFirst := true;
		end;
		vlCurrent := TFormulaNode(vlCurrent.fNxt);
	end;
	exit(false);
end;



function    TOperList.CreatePoc(ParCre :TSecCreator;ParMac1,ParMac2:TMacBase) : TMacBase;
begin
	exit(ParCre.CreateThreePoc(fPoc,ParMac1,ParMac2));
end;

function TOperList.CreateMac(ParOption:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var 	 vlCurrent   : TFormulaNode;
	vlSec       : TSubPoc;
	vlPoc       : TSubPoc;
	vlMac       : TMacBase;
	vlMac2      : TMacBase;
	vlNxt	     : TFormulaNode;
begin
	vlSec := TSubPoc.create;
	ParCre.AddSec(vlSec);
	vlPoc     := ParCre.fPoc;
	ParCre.SetPoc(vlSec);
	vlCurrent := TFormulaNode(fStart);
	vlMac := nil;
	
	if vlCurrent <> nil then begin
		vlNxt :=TFormulaNode(vlCurrent.fNxt);
		if (vlNxt <> nil) then begin
			if vlCurrent.fComplexity > vlNxt.fComplexity then begin
				vlMac := vlCurrent.CreateMac(ParOption,ParCre);
				vlMac2 := vlNxt.CreateMac(ParOption,parCre);
			end else begin
				vlMac2 := vlNxt.CreateMac(ParOption,ParCre);
				vlMac := vlCurrent.CreateMac(ParOption,parCre);
			end;
			vlMac := CreatePoc(ParCre,vlMac,vlMac2);
			vlNxt := TFormulaNode(vlNxt.fNxt);
		end else begin
			vlMac := vlCurrent.CreateMac(ParOption,ParCre);
		end;
		vlCurrent := vlNxt;
		while (vlCurrent <>  nil) and (vlMac <> nil) do begin
			vlMac2 := vlCurrent.CreateMac(ParOption,ParCre);
			vlMac := CreatePoc(ParCre,vlMac,vlMac2);
			vlCurrent := TFormulaNode(vlCurrent.fNxt);
		end;
	end;
	ParCre.SetPoc(vlPoc);
	exit(vlMac);
end;



function  TOperList.CanOptimize1:boolean;
begin
	CanOptimize1 := false;
end;

procedure TOperList.CalculateOperator(ParCre : TCreator;var ParResult:TNumber;ParPos : cardinal;ParValue:TNUmber);
begin
end;

function  TOperList.Optimize1(ParCre:TCreator):boolean;
var vlCurrent      : TOperNode;
	vlHasOptimized : boolean;
	vlResult       : TNumber;
	vlNxt          : TOperNode;
	vlNum          : TNumber;
	vlValue	   : TValue;
	vlOpt	   : boolean;
	vlCan          : boolean;
	vlFound 	   : cardinal;
	vlPos	   : cardinal;
begin
	vlCurrent := TOperNode(fStart);
	if (vlCurrent <> nil) and (vlCurrent.fNxt = nil) then begin
		vlOpt := false;
		if not vlCurrent.fCanDelete then vlOpt := vlCurrent.Optimize1(ParCre);
		if inherited Optimize1(ParCre) then vlOpt := true;
		exit(vlOpt);
	end;
	vlHasOptimized := false;
	vlCan    := CanOptimize1;
	if CanOptimize1 then begin
		vlCan := CheckOptimize1Method;
	end;
	vlFound  := 0;
	vlPos    := 0;
	GetFirstValue(vlResult);
	if inherited Optimize1(ParCre) then vlHasOptimized  := true;
	if vlCan then begin
		while vlCurrent<> nil do begin
			inc(vlPos);
			vlNxt := TOperNode(vlCurrent.fNxt);
			if not vlCurrent.fCanDelete then begin
				vlValue := vlCurrent.GetValue;
				if vlValue <> nil then begin
					if not vlValue.GetNumber(vlNum) then begin
						CalculateOperator(ParCre,vlResult,vlPos,vlNum);
						inc(vlFound);
						vlCurrent.SetCanDelete(true);
					end;
					vlValue.Destroy;
				end;
			end;
			vlCurrent := vlNxt;
		end;
		if (vlFound > 0) then begin
			vlHasOptimized := (vlFound > 1);
			{ if} AddOptimizedValue(ParCre,vlResult) {then vlHasOptimized := true;}
		end;
	end;
	DeleteIfCan(ParCre);
	if inherited Optimize1(parCre) then vlHasOptimized := true;
	exit(vlHasOptimized);
end;

procedure TOperList.GetFirstValue(var ParValue : TNumber);
begin
	LoadInt(ParValue,0);
end;

function TOperList.AddOptimizedValue(ParCre : TCreator;ParValue : TNumber):boolean;
var vlResNode : TNodeIdent;
begin
	vlResNode := TNDCreator(ParCre).CreateIntNode(ParValue);
	if vlResNode <> nil then AddNode(ParCre,vlResNode);
	exit(true);
end;

function  TOperlist.HandleNode(ParCre:TSecCreator;ParNode:TNodeIdent):boolean;
begin
	ParCre.AddSec(TUnkPoc.create(self.className));
	HandleNode := true;
end;

constructor  TOperList.Create(ParPoc:TRefFormulaPoc);
begin
	inherited Create;
	fPoc := (ParPoc);
end;

{-----( TThenELseNode)---------------------------------------}

function  TThenElseNode.CreateSec(ParCre:TSecCreator):boolean;
begin
	CreateSec := CreatePartsSec(ParCre);
end;

procedure TTHenElseNode.Print(ParDis:TDisplay);
begin
	if iThenElse then begin
		ParDis.WriteNl('<then>')
	end else begin
		PArDis.WriteNl('<else>');
	end;
	iParts.Print(PArDis);
	if iThenElse then begin
		ParDis.WriteNl('</then>')
	end else begin
		PArDis.WriteNl('</else>');
	end;

end;
constructor TThenElseNode.Create(ParThenElse:boolean);
begin
	inherited Create;
	iThenElse := ParThenElse;
end;



{----( TLogicList )-----------------------------------------}


constructor TLogicList.Create(ParPoc : TRefFormulaPoc;ParWhen:boolean);
begin
	inherited Create(ParPoc);
	iWhen := ParWhen;
end;



function TLogicList.HandleNode(ParCre:TSecCreator;ParNode:TNodeIdent):boolean;
var vlLab,vlOth:TLabelPoc;
begin
	vlOth := nil;vlLab := nil;
	if not ParNode.IsLast then begin
		vlOth := ParCre.CreateLabel;
		if iWhen then vlLab := ParCre.SetLabelFalse(vlOth)
		else vlLab := Parcre.SetLabelTrue(vlOth);
	end;
	ParNode.CreateSec(ParCre);
	if not ParNode.isLast then begin
		ParCre.Addsec(vlOth);
		if iWhen then ParCre.SetLabelFalse(vlLab)
		else ParCre.SetLabelTrue(vlLab);
	end;
	HandleNode := false;
end;

{---( TLogicNode )------------------------------------------------}

function TlogicNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlLabTrue  : TLabelPoc;
	vlLabFalse : TLabelPoc;
	vlPrvTrue  : TLabelPoc;
	vlPrvFalse : TLabelPoc;
begin
	case ParOpt of
	MCO_Result:begin
		if not TFormulaNode(GetPartByNum(1)).IsLikeType(TBooleanType) then begin
			CreateMac := inherited CreateMac(ParOpt,ParCre);
		end
		else begin
			vlPrvTrue := ParCre.fLabelTrue;
			vlPrvFalse:= ParCre.fLabelFalse;
			vlLabTrue := parCre.CreateLabel;
			vlLabFalse:= ParCre.CreateLabel;
			ParCre.SetLabelTrue(vlLabTrue);
			ParCre.SetLabelFalse(vlLabFalse);
			CreateSec(ParCre);
			CreateMac := parCre.ConvJumpToBool(GetType.fSize);
			ParCre.SetLabelTrue(vlPrvTrue);
			ParCre.SetLabelFalse(vlPrvFalse);
		end;
	end
	else inherited CreateMac(ParOpt,ParCre);
end;
end;


function TLogicNode.CheckNode(ParNode:TFormulaNode):boolean;
begin
	if GetType = nil then begin
		 CheckNode :=  (not ParNode.IsCompByIdentCode(IC_Number))
						and not(PArNode.IsLikeType(TBooleanType));
	end
	else begin
		CheckNode :=  not IsDirectComp(ParNode);
	end;
end;



{---( TNotNode )--------------------------------------------------}

procedure TNotNode.GetOperStr(var ParOper:String);
begin
	ParOper := 'NOT';
end;


procedure TNotNode.CommonSetup;
begin
	inherited COmmonSetup;
	iIdentCode  := IC_NotNode;
	iComplexity := CPX_Not;
end;

procedure TNotNode.InitParts;
begin
	SetParts((TLogicList.create(TNotFor,false)));
end;



function TNotNode.CreateSec(ParCre:TSecCreator):boolean;
begin
	ParCre.SwapLabels;
	GetPartByNum(1).CreateSec(ParCre);
	ParCre.SwapLabels;
	CreateSec := false;
end;

procedure TNotNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.writenl('<not>');
	iParts.print(ParDis);
	ParDis.writenl('</not>');
end;


function TNotNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlNotFor:TNotFor;
	vlMac   :TMacBase;
begin
	case ParOpt of
		MCO_Result:begin
			vlNotfor := TNotFor.create;
			vlNotfor.SetVar(1,iParts.CreateMac(ParOpt,Parcre));
			ParCre.AddSec(vlNotFor);
			vlMac := vlNotFor.CalcOutputMac(ParCre);
		end;
		else vlMac := inherited createMac(ParOpt,ParCre);
	end;
	exit(vlMac);
end;



{---( TAndNode )--------------------------------------------------}


procedure TAndNode.InitParts;
begin
	SetParts((TLogicList.create(TAndFor,false)));
end;


function  TAndNode.CreateSec(ParCre:TSecCreator):boolean;
begin
	CreatePartsSec(ParCre);
	CreateSec := false;
end;


procedure TAndNode.GetOperStr(var PArOper:string);
begin
	ParOper := 'AND';
end;


procedure TAndNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_AndNode;
	iComplexity := CPX_And;
end;


{---( TOrNode )--------------------------------------------------}

function  TOrNode.CreateSec(ParCre:TSecCreator):boolean;
begin
	CreatePartsSec(ParCre);
	CreateSec := false;
end;


procedure TOrNode.initParts;
begin
	SetParts(TLogicList.create(TOrFor,true));
end;


procedure TOrNode.GetOperStr(Var ParOper:String);
begin
	ParOper := 'OR';
end;

procedure TOrNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_OrNode;
	iComplexity := CPX_Or;
end;


{---( TXorNode )--------------------------------------------------}


procedure TXorNode.initParts;
begin
	SetParts(TOperList.create(TXorFor));
end;


procedure TXorNode.GetOperStr(var ParOper:string);
begin
	ParOper := 'XOR';
end;

procedure TXorNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_XorNode;
	iComplexity := CPX_XOr;
end;

function TXorNode.CreateMac(ParOpt:TMacCreateOption;parCre:TSecCreator):TMacBase;
begin
	exit(iParts.CreateMac(ParOpt,ParCre));
end;


function TXorNode.CreateSec(ParCre:TSecCreator):boolean;
var vlMac  : TMacBase;
	vlComp : TCompFor;
	vlOut  : TMacBase;
	vlNum  : TLargeNumber;
begin
	vlMac := CreateMac(MCO_Result,ParCre);
	vlComp := TCompFor.Create(IC_NotEq);
	vlComp.SetVar(1,vlMac);
	LoadInt(vlNum,0);
	vlComp.SetVar(2,ParCre.CreateNumberMac(vlMac.fSize,false,vlNum));
	vlOut := vlComp.CalcOutputMac(ParCre);
	ParCre.AddSec(vlComp);
	ParCre.MakeJumpFromCond(vlOut);
	CreateSec:= false;
end;

{---( TExitNode )-------------------------------------------------}


procedure TExitNode.Optimize(ParCre:TCreator);
begin
	inherited Optimize(ParCre);
	if iReturnInstruction <> nil then  iReturnInstruction.Optimize(ParCre);
end;

procedure   TExitNode.ValidateAfter(parCre : TCreator);
begin
	inherited ValidateAfter(ParCre);
	if (iReturnInstruction <> nil) then iReturnInstruction.ValidateAfter(ParCre);
end;


function    TExitNode.CreateSec(ParCre:TSecCreator):boolean;
var
	vlCb     : TRoutinePoc;
	vlJump   : TJumpPoc;
begin
	if iReturnInstruction <> nil then iReturnInstruction.CreateSec(ParCre);
	vlCb := TRoutinePoc(ParCre.fCurrentProc);
	if vlCb = nil then fatal(fat_RoutinePoc_Not_Set,'At:TExitNode.CreateSec');
	vlJump := TJumpPoc.Create(vlCb.CreateExitLabel);
	ParCre.AddSec(vlJump);
	CreateSec := false;
end;


constructor TExitNode.Create(ParReturnType : TType;ParReturnInstruction : TNodeIdent);
begin
	inherited Create;
	iReturnInstruction := ParReturnInstruction;
	iReturnType        := ParReturnType;
end;

procedure TExitNode.clear;
begin
	inherited Clear;
	if iReturnInstruction <> nil then iReturnInstruction.Destroy;
end;

procedure TExitNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.Writenl('<exit>');
	if iReturnType <> nil then begin
		ParDis.writenl('<type>');
		iReturnType.PrintName(ParDis);
		ParDis.Writenl('</type>');
	end;
	if iReturnInstruction <> nil then begin
		ParDis.nl;
		ParDis.WriteNl('<expression>');
		ParDis.SetLeftMargin(3);
		iReturnInstruction.Print(ParDis);
		ParDis.SetLeftMargin(-3);
		ParDis.nl;
		ParDis.Writenl('</expression');
	end;
	ParDis.Writenl('</exit>');
end;



{---( TConditionNode )---------------------------------------------}


function  TConditionNode.SetVarUseItem(ParCre : TSecCreator;ParMode : TAccessMode;var ParUseList : TVarUseList;var ParItem : TVarUseItem) : TAccessStatus;
begin
	iCond.ValidateVarUse(ParCre,ParMode,ParUseList);
	inherited SetVarUseItem(ParCre,ParMode,ParUseList,ParItem);
	exit(AS_Normal);
end;

procedure TConditionNode.ValidateAfter(ParCre  : TCreator);
begin
	inherited ValidateAfter(ParCre);
	if iCond <> nil then iCond.ValidateAfter(ParCre);
end;

procedure TConditionNode.CommonSetup;
begin
	inherited CommonSetup;
	iCond := nil;
end;

procedure  TConditionNode.Optimize(ParCre : TCreator);
begin
	inherited Optimize(ParCre);
	iCond := OptimizeThisNode(ParCre,iCond);
end;


procedure TConditionNode.SetCond(ParCre :TNDCreator;ParCond:TFormulaNode);
begin
	if iCond<> nil then iCond.Destroy;
	iCond := ParCond;
	if ParCond <> nil then begin
		if not ParCond.Can([Can_Read]) then ParCre.SemError(Err_Cant_Read_From_Expr);
		if not ParCond.IsLikeType(TBooleanType) then ParCre.SemError(Err_Wrong_Type);
	end;
end;

destructor TConditionNode.Destroy;
begin
	inherited Destroy;
	if iCond <> nil then iCond.Destroy;
end;


{---( TRepeatNode )-----------------------------------------------}



function    TRepeatNode.CreateSec(ParCre:TSecCreator):boolean;
var vlLabFalse,vlLabTrue:TLabelPoc;
	vlPrvFalse,vlPrvtrue:TLabelPoc;
begin
	vlLabFalse  := ParCre.AddLabel;
	vlLabTrue   := GetBreakLabel;
	CreatePartsSec(ParCre);
	vlPrvFalse := ParCre.SetLabelFalse(vlLabFalse);
	vlPrvTrue  := ParCre.SetLabelTrue(vlLabTrue);
	ParCre.AddSec(GetContinueLabel);
	iCond.CreateSec(ParCre);
	ParCre.SetLabelFalse(vlPrvFalse);
	ParCre.SetLabelTrue(vlPrvTrue);
	ParCre.AddSec(vlLabtrue);
	CreateSec := false;
end;

procedure TRepeatNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.WriteNl('<repeat><code>');
	iParts.Print(ParDis);
	ParDis.WriteNl('</code></until>');
	if iCond <> nil then begin
		iCond.PrintNode(ParDis);
		ParDis.nl;
	end;
	ParDis.Write('</until></repeat>');
end;


{--------( TPointerNode )-------------------------------------------}


constructor TPointerNode.Create(ParNum:TPointerCons);
begin
	inherited Create(ParNum);
end;

destructor  TPointerNode.Destroy;{clear}
begin
	inherited Destroy;
	fVariable.Destroy;
end;


procedure TPointerNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_NumNode;
	iCOmplexity := CPX_Pointer;
end;


procedure TPointerNode.PrintNode(ParDis:TDisplay);
var
	vlName : string;
begin
	ParDis.Write('<pointer>');
	if fVariable <> nil then begin
		fVariable.GetTextStr(vlName);
		ParDis.Write(vlName);
	end;
	ParDis.Write('</pointer>');
end;


{--------( TBoolOperNode )--------------------------------------}

procedure TBoolOperNode.ValidateNode(ParCre : TCreator;var parNode:TNodeIdent);
var
	vlType :TType;
begin
	if not TFormulaNode(ParNode).Can([Can_Read]) then begin
		TNDCreator(ParCre).SemError(Err_cant_Read_From_expr);
	end;
	if iParts.IsEmpty then begin
		if not((TFormulaNode(ParNode).IsCompByIdentCode(IC_Number))
		or (TFormulaNode(ParNode).IsCompByIdentCode(IC_CHarType))
		or (TFormulaNode(ParNode).IsCompByIdentCode(IC_PtrType))
		or (TFormulaNode(ParNode).IsCompByIdentCode(IC_RoutineType))
		or (TFormulaNode(ParNode).IsCompByIdentCode(IC_EnumType))
		or (TFormulaNode(ParNode).IsLikeType(TBooleanType)))
		then begin
			TNDCreator(ParCre).ErrorText(Err_Invalid_Operation,'xx');
		end;
	end else begin
		vlType := TFormulaNode(iParts.fStart).GetType;
		if CheckCOnvertNode(ParCre,vlType,TFormulaNode(ParNode)) then TNDCreator(ParCre).ErrorDef(Err_Wrong_Type,vlType);
	end;
end;


constructor TBoolOperNode.Create(ParBooleanType:TType);
begin
	inherited Create;
	iBooleanType := ParBooleanType;
end;

function    TBoolOperNode.GetType:TType;
begin
	exit(iBooleanType);
end;


{--------( TModNode )-------------------------------------------}

procedure TModNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := (IC_DivNode);
	iComplexity := CPX_Mod;
end;

procedure TModNode.GetOPerStr(var ParOper:String);
begin
	ParOper := 'MOD';
end;


procedure TModNode.InitParts;
begin
	SetParts(TOperList.Create(TModFor));
end;

{--------( TDivNode )-------------------------------------------}


procedure TDivNode.InitParts;
begin
	SetParts(TOperList.Create(TDivFor));
end;

procedure TDivNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_DivNode;
	iComplexity := CPX_Div;
end;

procedure TDivNode.GetOPerStr(var ParOper:String);
begin
	ParOper := '/';
end;



{--------( TnegNode )-------------------------------------------}

function  TNegNode.GetReplace(ParCre:TCreator):TNodeIdent;
var vlValue : TValue;
	vlNum   : TNumber;
	vlNode  : TFormulaNode;
	vlType  : TType;
begin
	if iParts.GetNumItems = 1 then begin
		vlNode  := TFormulaNode(iParts.fStart);
		vlValue := vlNode.GetValue;
		if (vlValue <> nil) then begin
			if not (vlValue.GetNumber(vlNum)) then begin
				vlValue.Neg;
				LargeNeg(vlNum);
				vlType := TNDCreator(ParCre).GetIntType(vlNum,vlNum);
				exit(TConstantValueNode.Create(vlValue,vlType));
			end;
			vlValue.Destroy;
		end;
	end;
	exit(nil);
end;

function  TNegNode.AddNode(ParCre:TCreator;parNode:TNodeIdent):boolean;
var vlType    : TType;
	vlOrgType : TType;
	vlNode    : TNodeIdent;
begin
	if not iParts.IsEmpty then runerror(1);
	if ParNode <> Nil then begin
		vlOrgType := TFormulaNode(ParNode).GetType;
		vlNode    := ParNode;
		if vlOrgType <> nil then begin
			if not  vlOrgType.GetSign then begin
				vlType := TNDCreator(ParCre).GetDefaultIdent(DT_Number,vlOrgType.fSize * 2,true);
				if vlType <> nil then begin
					vlNode := TLoadConvert.Create(vlType);
					vlNode.AddNode(ParCre,ParNode);
				end;
			end
		end;
		exit(inherited AddNode(ParCre,vlNode));
	end else begin
		exit(false);
	end;
end;


procedure TNegNode.GetOperStr(var ParOper:string);
begin
	ParOper := 'NEG';
end;

procedure TNegNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := (IC_NegNode);
	iComplexity := CPX_Neg;
end;


function TNegNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlNegFor:TNegFor;
	vlMac   :TMacBase;
begin
	case ParOpt of
		MCO_Result:begin
			vlNegfor := TNegFor.create;
			vLnegfor.SetVar(1,iParts.CreateMac(ParOpt,Parcre));
			ParCre.AddSec(vlNegFor);
			vlMac := vlNegFor.CalcOutputMac(ParCre);
		end;
		else vlMac := inherited createMac(ParOpt,ParCre);
	end;
	exit(vlMac);
end;

{--------( TShrNode )-------------------------------------------}


procedure TShrNode.InitParts;
begin
	SetParts(TShrNodeList.Create(TShrFor));
end;

Procedure TShrNode.GetOperStr(var ParOper : string);
begin
	ParOper := 'SHR';
end;


procedure TShrNode.Commonsetup;
begin
	inherited Commonsetup;
	iIdentCode := IC_ShrNode;
end;

{--------( TShlNode )-------------------------------------------}


procedure TShlNode.InitParts;
begin
	SetParts(TShrNodeList.Create(TShlFor));
end;

Procedure TShlNode.GetOperStr(var ParOper : string);
begin
	ParOper := 'SHL';
end;


procedure TShlNode.Commonsetup;
begin
	inherited Commonsetup;
	iIdentCode := IC_ShlNode;
end;

{--------( TMulNode )-------------------------------------------}




procedure TMulNode.InitParts;
begin
	SetParts(TMulNodeList.create(TMulFor));
end;

procedure TMulNode.GetOperStr(var ParOper:String);
begin
	ParOper := '*';
end;

procedure TMulNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := IC_MulNode;
	iComplexity:= CPX_Mul;
end;


{------( TMulNodeLIst )-----------------------------------------}


function TMulNodeList.CanOptimizeCpx:boolean;
begin
	exit(true);
end;

function TMulNodeList.AddOptimizedValue(ParCre : TCreator;ParValue : TNumber):boolean;
var vlAdd : boolean;
begin
	vlAdd := false;
	if LargeCompareLong(ParValue,1)<> LC_Equal then vlAdd := inherited AddOptimizedValue(ParCre,ParValue);
	exit(vlAdd);
end;

procedure  TMulNodeList.GetFirstValue(var ParValue : TNumber);
begin
	LoadInt(ParValue,1);
end;

function  TMulNodeList.CanOptimize1:boolean;
begin
	CanOptimize1 := true;
end;

procedure TMulNodeList.CalculateOperator(ParCre : TCreator;var ParResult:TNumber;ParPos : cardinal;ParValue:TNumber);
begin
	if LargeMul(ParResult,ParValue) then TNDCreator(ParCre).AddNodeListError(self,Err_NuM_Out_Of_range,'');
end;


{------( TOrdDualOperNode )------------------------------------}

procedure TOrdDualOperNode.SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);
var
	vlTypeName : string;
begin
	inherited  SafeValidateNode(ParCre,ParNode);
	if not(TFormulaNode(ParNode).IsCompByIdentcode(IC_Number)) then begin
		TFormulaNode(ParNode).GetTypeName(vlTypeName);
		TNDCreator(ParCre).ErrorText(Err_Wrong_Type,vlTypeName);
	end;
end;



{------( TDualOperNode )----------------------------------------}


procedure TDUalOperNode.SafeValidateNode(ParCre : TCreator;var parNode:TNodeIdent);
begin
	inherited SafeValidateNode(ParCre,ParNode);;
	if not(TFormulaNode(Parnode).Can([Can_Read])) then TNDCreator(ParCre).ErrorText(Err_Cant_Read_From_Expr,'3');
end;

function TDualOperNode.GetReplace(ParCre:TCreator):TNodeIdent;
var
	vlItem:TNodeIdent;
begin
	GetReplace := nil;
	if iParts.GetNumItems <= 1 then begin
		vlItem := TNodeIdent(iParts.fStart);
		if vlItem <> nil then iParts.CutOut(vlItem);
		GetReplace := vlItem;
		SetCanDelete(true);
	end;
end;


{-------( TLoadNode )---------------------------------------------}


procedure TLoadNOde.ValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
begin
end;

function TLoadNode.CheckConvertTest(ParType1,ParType2 :TType) : boolean;
begin
	if ParType1 <> nil then begin
		exit(ParType1.CanWriteWith(false,ParType2));
	end else begin
		exit(false);
	end;
end;


procedure TLoadNode.ValidateAfter(ParCre : TCreator);
var vlFirst     : TFormulaNode;
	vlSecond    : TFormulaNode;
	vlType      : TType;
	vlName1     : string;
	vlName2     :string;
begin
	inherited ValidateAfter(ParCre);
	vlFirst  := TFormulaNode(GetPartByNUm(1));
	vlSecond := TFormulaNode(GetPartByNum(2));
	vlType := GetType;
	if (vlFirst <> nil) and (vlSecond <> nil) then begin
		if vlFirst.GetSize = 0 then TNDCreator(ParCre).AddNodeError(vlFirst,Err_Cant_Determine_Size,'');
		if vlSecond.GetSize = 0 then TNDCreator(ParCre).AddNodeError(vlSecond,Err_Cant_Determine_Size,'');
		if not vlFirst.Can([Can_Write]) then TNDCreator(ParCre).AddNodeError(vlFirst,Err_Cant_Write_To_Item,'');
		if not vlSecond.Can([Can_Read]) then TNDCreator(ParCre).AddNodeError(vlSecond,Err_Cant_Read_From_expr,'');
		if (vlType <> nil) then begin
			if CheckConvertNode2(ParCre,vlType,vlSecond) then begin
				vlName1 := 'unkown';
				vlName2 := 'unkown';
				vlSecond := TFormulaNode(GetPartByNum(2));
				if vlType <>nil then  vlName1 := vlType.GetErrorName;
				if vlSecond.GetType <> nil then  vlName2 := vlSecond.GetType.GetErrorName;
				TNDCreator(ParCre).AddNodeError(vlFirst,Err_Incompatible_types,'Expression '+vlName2+' loaded into '+vlName1);
			end;
		end;
		vlType := vlFirst.GetType;
		if vlTYpe <> nil then vlSecond.ValidateConstant(ParCre,@vlType.ValidateConstant);
	end;
end;

function TLoadNode.CheckNode(ParNode : TFormulaNode):boolean;
begin
	exit(false);
end;

function  TLoadNode.SetVarUseItem(ParCre : TSecCreator;ParMode : TAccessMode;var ParUseList : TVarUseList;var ParItem : TVarUseItem) : TAccessStatus;
var
	vlFirst  : TFormulaNode;
	vlSecond : TFormulaNode;
begin
	vlFirst  := TFormulaNode(GetPartByNUm(1));
	vlSecond := TFormulaNode(GetPartByNum(2));
	vlSecond.ValidateVarUse(ParCre,AM_Read,ParUseList);
	vlFirst.ValidateVarUse(ParCre,AM_Write,ParUseList);
	ParItem := nil;
	exit(AS_Normal);
end;

function TLoadNode.CreateSec(ParCre:TSecCreator):boolean;
var vlPoc    : TLoadFor;
	vlFirst  : TFormulaNode;
	vlSecond : TFormulaNode;
	vlSource : TMacBase;
	vlDest   : TMacBase;
	vlMac1   : TMacBase;
	vlMac2   : TMacBase;
begin
	vlFirst  := TFormulaNode(GetPartByNUm(1));
	vlSecond := TFormulaNode(GetPartByNum(2));
	if (vlFirst.GetSize >GetAssemblerInfo.GetSystemSize) or (vlFirst.GetSize = 3)  then begin
		vlDest   := vlFirst.CreateMac(MCO_Result,ParCre);
		vlSource := vlSecond.CreateMac(MCO_Result,ParCre);
		vlPoc    := TLoadFor(TLSMovePoc.Create(vlSource,vlDest,vlFirst.GetSize));
		ParCre.AddSec(vlPoc);
	end else begin
		vlPoc := TLoadFor.create;
		if (vlSecond.fComplexity > vlFirst.fComplexity) then begin
			vlMac1 := vlSecond.CreateMac(MCO_Result,ParCre);
			vlMAc2 := vlFirst.CreateMac(MCO_Result,ParCre);
		end else begin
			vlMAc2 := vlFirst.CreateMac(MCO_Result,ParCre);
			vlMac1 := vlSecond.CreateMac(MCO_Result,ParCre);
		end;
		vlPoc.SetVar(1,vlMac1);
		vlPoc.SetVar(Mac_Output,vlMac2);
		ParCre.AddSec(vlPoc);
	end;
	if vlFirst.IsOptUnsave then begin
		ParCre.AddSec(TOptUnSavePoc.Create);
	end;
	CreateSec := false;
end;


procedure TLoadNode.getOperStr(Var ParOper:string);
begin
	ParOper := ':=';
end;


procedure TLoadNode.CommonSetup;
begin
	inherited CommonSetup;
	iIdentCode := (IC_LoadNode);
end;





{----( TByPtrNode )-----------------------------------------}

function TByPtrNode.IsOptUnsave:boolean;
begin
	exit(true);
end;


function TByPTrNode.Can(ParCan:TCan_Types):boolean;
var
	vlNode  : TFormulaNode;
	vlType  : TPtrType;
	vlFlags : TCan_Types;
	vlDestType : TType;
begin
	vlFlags := ParCan * [CAN_Size, Can_Dot,Can_Type,Can_Execute,Can_Index];
	if vlFlags <> [] then begin
		vlDestType := GetOrgType;
		if (vlDestType = nil) or not(vlDestType.Can(vlFlags)) then exit(false);
		ParCan := ParCan - vlFlags;
	end;
	vlNode := TFormulaNode(GetPartByNum(1));
	if(vlNode <> nil) then begin
		vlType :=  TPtrType(vlNode.GetOrgType);
		if(vlType <> nil) then begin
			if (vlType is TPtrType) and not vltype.fConstFlag then ParCan := ParCan - [Can_Write];
		end;
	end;
	exit( inherited Can(ParCan - [CAN_Pointer]));
end;


procedure TByPtrNode.GetOperStr(var ParOper:string);
begin
	ParOper := 'ByPtr';
end;

procedure TByPtrNode.commonsetup;
begin
	inherited Commonsetup;
	iIdentCode := (IC_ByPtrNode);
	iExtraOffset := 0;
	iCOmplexity := CPX_ByPointer;
end;


function TByPtrNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var
	vlMac  : TMacBase;
	vlNode : TNodeIdent;
	vlType : TType;
	vlRef  : TMacBase;
	vlPtrType:TType;
begin
	case ParOpt of
	MCO_Result:begin
		vlNode    := GetPartByNum(1);
		vlType    := TFormulaNode(vlNode).GetType;
		vlMac     := TNodeIdent(vlNode).CreateMac(MCO_Result,ParCre);
		vlPtrType := TPtrTYpe(vltype).fType;
		vlRef     := TByPointerMac.create(vlPtrType.fSize,vlPtrType.GetSign,vlMac);
		ParCre.AddObject(vlRef);
		vlRef.AddExtraOffset(iExtraOffset);
		CreateMac := vlRef;
	end;
	MCO_ValuePointer,MCO_ObjectPointer:CreateMac := TNodeIdent(GetPartByNum(1)).CreateMac(MCO_Result,ParCre);
	else CreateMac := inherited CreateMac(ParOpt,ParCre);
end;
end;

procedure TByPTrNode.SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
var vlType : TPtrType;
begin
	inherited SafeValidateNode(ParCre,ParNode);
	vlType := TPtrType(TFormulaNode(ParNode).GetOrgType);
	if not (vlType is TPtrType) then TNDCreator(ParCre).SemError(Err_Not_A_Pointer_Type) else
	if vlType.GetSecSize = 0 then TNDCreator(PArCre).SemError(Err_Cant_Determine_Size);
end;


function TByPtrNode.GetType:TType;
var
	vlOther:TFormulaNode;
	vlType : TType;
begin
	vlOther := TFormulaNode(iParts.fStart);
	vlType  := nil;
	if vlOther <> nil then begin
			vlType := vlOther.GetOrgType;
			if (vlType <> nil) and (vlType is TPtrType) then begin
				vlType := TPtrType(vlType).fType;
			end else begin
				vlType := nil;
			end;
	end;
	exit(vlType);
end;



{----( TOrdOperNode )---------------------------------------}

procedure TOrdOperNode.SafeValidateNode(ParCre : TCreator;var ParNode:TNodeIdent);
var vlTypeName : string;
begin
	inherited  SafeValidateNode(ParCre,ParNode);
	if not(TFormulaNode(ParNode).IsCompByIdentcode(IC_Number)) then begin
		TFormulaNode(ParNode).GetTypeName(vlTypeName);
		TNDCreator(ParCre).ErrorText(Err_Wrong_Type,vlTypeName);
	end;
end;


{---( TValueOperNode )--------------------------------------}

procedure TValueOperNode.SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
begin
	inherited SafeValidateNode(ParCre,ParNode);
	if not TFormulaNode(ParNode).Can([Can_Read]) then TNDCreator(ParCre).ErrorText(Err_Cant_Read_From_Expr,'4');
end;

{----( TOperNode )------------------------------------------}


function TOperNode.CheckConvertTest(ParType1,ParType2 : TType) : boolean;
begin
	exit(ParType1.IsDirectComp(ParType2));
end;

function TOperNode.CheckConvertNode(ParCre :TCreator;ParType :TType;var ParNode : TFormulaNode):boolean;
var vlType : TType;
	vlNode2 : TFormulaNode;
begin
	vlType := ParNode.GetType;
	if parNode = nil then exit(false);
	if (vlType <> nil) and (ParType <> nil) then begin
		if not CheckConvertTest(ParType,vlType) then begin
			if ParNode.ConvertNodeType(ParType,ParCre,vlNode2) then begin
				if vlNode2 <> nil then begin
					ParNode.Destroy;
					ParNode := vlNode2;
				end;
				exit(false);
			end;
			exit(true);
		end;
	end;
	exit(false);
end;


function TOperNode.CheckConvertNode2(ParCre :TCreator;ParType :TType;var ParNode : TFormulaNode):boolean;
var vlType : TType;
	vlNode2 : TFormulaNode;
begin
	vlType := ParNode.GetType;
	if parNode = nil then exit(false);
	if (vlType <> nil) and (ParType <> nil) then begin
		if not CheckConvertTest(ParType,vlType) then begin
			if ParNode.ConvertNodeType(ParType,ParCre,vlNode2) then begin
				if vlNode2 <> nil then begin
					fParts.InsertAt(ParNode,vlNode2);
					fParts.CutOut(ParNode);
					ParNode.Destroy;
					ParNode := vlNode2;
				end;
				exit(false);
			end;
			exit(true);
		end;
	end;
	exit(false);
end;

procedure TOperNode.Get2SubNode(var ParFirst,ParSecond:TFormulaNode);
begin
	ParFirst := TFormulaNode(iParts.fStart);
	if ParFirst <> nil then begin
		ParSecond := TFormulaNode(ParFirst.fNxt)
	end else begin
		ParSecond := nil;
	end;
end;

function  TOperNode.CheckNodeIsSafe(ParNode : TNodeIdent) : boolean;
begin
	exit((ParNode <> nil) and  (ParNode is TFormulaNode) and (TFormulaNode(ParNode).GetOrgType <> nil));
end;



procedure TOperNode.SafeValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
begin
	inherited SafeValidateNode(ParCre,ParNode);
	if (CheckNode(TFormulaNode(ParNode))) then begin
		TNDCreator(ParCre).SemError(Err_Invalid_Operation);
	end;
end;

procedure TOperNode.ValidateNode(ParCre : TCreator;var ParNode : TNodeIdent);
var vlType : TType;
begin
	inherited ValidateNode(ParCre,ParNode);
	vlType := TFormulaNode(ParNode).GetType;
	if (vlType = nil ) and (ParNode.fIdentCode <> IC_ProcedureNode) then begin
		TNDCreator(ParCre).SemError(Err_Cant_Determine_Size);
	end;
end;

function  TOperNode.CheckNode(ParNode:TFormulaNode):boolean;
begin
	CheckNode := false;
end;

procedure TOperNode.GetOperStr(var ParOper:string);
begin
	ParOper := '<unkown>';
end;



procedure TOperNode.InitParts;
begin
	SetParts(TOperList.create(nil));
end;

function  TOperNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
begin
	if ParOpt=MCO_Result then begin
		exit( iParts.CreateMac(ParOpt,ParCre));
	end else begin
		exit(inherited CreateMac(ParOpt,ParCre));
	end;
end;


function  TOperNode.AddNode(ParCre:TCreator;parNode:TNodeIdent):boolean;
begin
	AddNode := false;
	if inherited AddNode(ParCre,ParNode) then AddNode := true;
end;


procedure TOperNode.PrintNode(ParDis:TDisplay);
var vlStr:string;
begin
	GetOperStr(vlStr);
	ParDis.print(['<operator><kind>',vlStr,'</kind><operands>']);
	iParts.Print(ParDis);
	ParDis.print(['</operands></operator>']);
end;



function TOperNode.Can(ParCan:TCan_Types):boolean;
var vlCan:boolean;
begin
	vlCan := true;
	if (Can_Read in ParCan)then begin
		vlCan := TFormulaList(iParts).Can([Can_Read]);
		ParCan := PArCan - [CAN_Read];
	end;
	Can := vlCan and inherited Can(ParCan);
end;



function TOperNode.GetType:TType;
begin
	GetType :=TFormulaList(iParts).fFormType;
end;


{----( TWhileNode )-------------------------------------------}


function    TWhileNode.CreateSec(ParCre:TSecCreator):boolean;
var vlJump1    : TJumpPoc;
	vlLab1     : TLabelPoc;
	vlLab2     : TLabelPoc;
	vlPrvTrue  : TLabelPoc;
	vlPrvFalse : TLabelPoc;
begin
	vlJump1        := TJumpPoc.create(GetContinueLabel);
	ParCre.AddSec(vlJump1);
	vlLab1         := ParCre.AddLabel;
	CreatePartsSec(ParCre);
	vlLab2         := GetBreakLabel;
	ParCre.AddSec(vlJump1.fLabel);
	vlPrvtrue      := ParCre.SetLabelTrue(vlLab1);
	vlPrvFalse     := ParCre.SetLabelFalse(vlLab2);
	iCond.CreateSec(ParCre);
	ParCre.SetLabeLTrue(vlPrvTrue);
	ParCre.SetLabelFalse(vlPrvFalse);
	ParCre.AddSec(vlLab2);
	exit(false);
end;

procedure   TWhileNode.PrintNode(ParDis:TDisplay);
begin
	ParDis.WriteNl('<while>');
	ParDis.WriteNl('<condition>');
	iCond.Print(ParDis);
	ParDis.WriteNl('</condition><code>');
	iParts.Print(PArDis);
	ParDis.WriteNl('</code></while>');
end;


{---( TBetweenNode )----------------------------------------------}


procedure TBetweenNode.Commonsetup;
begin
	inherited Commonsetup;
	iIdentCode  := IC_BetweenNode;
	iComplexity := CPX_Between;
end;

procedure   TBetweenNode.PrintNode(ParDis:TDisplay);
var vlPar,vlExp1,vlExp2 :TNodeIdent;
begin
	vlPar := GetPArtByNum(1);
	vlExp1 := GetPartByNum(2);
	vlExp2 := GetPArtByNum(3);
	ParDis.Writenl('<between><ident>');
	if vlPar <> nil then vlPar.PrintNode(ParDis);
	ParDis.Nl;
	ParDis.Writenl('</ident><low>');
	if (vlExp1 <>nil) then vlExp1.PrintNode(ParDis);
	ParDis.Nl;
	ParDis.Writenl('</low><high>');
	if (vlExp2 <>nil) then vlExp2.PrintNode(ParDis);
	ParDis.Nl;
	ParDis.Writenl('</high>');
	
end;


function  TBetweenNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlPrvLabelTrue,vlPrvLabelFalse: TLabelPoc;
	vlLabelTrue,vlLabelFalse      : TLabelPoc;
	VLRESULT 			  : TMacBase;
begin
	if ParOpt <> MCO_Result then begin
		exit(inherited CreateMac(ParOpt,ParCre));
	end;
	vlPrvLabelTrue  := ParCre.fLabelTrue;
	vlPrvLabelFalse := ParCre.fLabelFalse;
	vlLabelTrue     := ParCre.CreateLabel;
	vlLabelFalse    := ParCre.CreateLabel;
	ParCre.SetLabelTrue(vlLabelTrue);
	ParCre.SetLabelFalse(vlLabelFalse);
	CreateSec(ParCre);
	vlResult := ParCre.ConvJumpToBool(GetTypeSize);
	ParCre.SetLabelTrue(vlPrvLabelTrue);
	ParCre.SetLabelFalse(vlPrvLabelFalse);
	exit(vlResult);
end;

function TBetweenNode.CreateSec(PArCre:TSecCreator):boolean;
var vlMac1         : TMacBase;
	vlMac2         : TMacBase;
	vlMac3         : TMacBase;
	vlMac4         : TMacBase;
	vlJmp          : TCondJumpPoc;
	vlJmp2         : TJumpPoc;
	vlLongResBEgin : TLOngResMetaPoc;
	vlLongResEnd   : TLongResMetaPoc;
	vlPar          : TFormulaNode;
	vlExp1         : TFormulaNode;
	vlExp2         : TFormulaNode;
	vlComp2        : TMacBase;
begin
	vlPar  := TFormulaNOde(GetPartByNum(1));
	vlExp1 := TFormulaNode(GetPartByNum(2));
	vlExp2 := TFormulaNode(GetPartByNum(3));
	vlLongResBegin := TLongResMetaPoc.create;
	vlLongResEnd   := TLongResMetaPoc.create;
	vlLongResBegin.fGroupEnd := vlLongResEnd;
	vlLongResEnd.fGroupBegin := vlLongResBegin;
	vlMac1 := vlPar.CreateMac(MCO_Result,ParCre);
	vlMac1 := vlLongResBegin.AddMac(ParCre,vlMac1);
	vlmac2 := TFormulaNode(vlExp1).CreateMac(MCO_Result,ParCre);
	PArCre.AddSec(vlLOngResBegin);
	vlMac3 := ParCre.MakeCompPoc(vlMac1,vlMac2,IC_Lower);
	vlJmp := TCondJumpPoc.create(true,vlMac3,ParCre.fLabelFalse);
	ParCre.AddSec(vlJmp);
	vlMac4  := TFormulaNode(vlExp2).CreateMAc(MCO_Result,ParCre);
	vlComp2 := vlMac1;
	vlMac3 := ParCre.MakeCompPoc(vlComp2,vlMac4,IC_Bigger);
	vlJmp := TCondJumpPoc.create(True,vlMac3,ParCre.fLabelFalse);
	ParCre.AddSec(vlJmp);
	vljmp2 := TJumpPoc.create(ParCre.fLabelTrue);
	ParCre.AddSec(vlLongResEnd);
	ParCre.AddSec(vlJmp2);
	CreateSec := false;
end;

{----( TCompNode )--------------------------------------------}

procedure TCompNode.ValidateNode(ParCre : TCreator;var parNode:TNodeIdent);
var
	vlNode1 : TFormulaNode;
	vlType1 : TType;
begin
	if ParNode = nil then exit;
	vlNode1 := TFormulaNode(iParts.fStart);
	if TFormulaNode(ParNode).GetTypeSize = 0 then TNDCreator(PArCre).AddNodeError(ParNode,Err_Cant_Determine_Size,'');
	if vlNode1 = nil then begin
		if  TFormulaNode(ParNode).IsLikeType(TClassTYpe) then exit;
	end else begin
		if TFormulaNode(vlNode1).IsLikeType(TClassType) or TFormulaNode(ParNode).IsLikeType(TClassType) then begin
			if (TFormulaNode(vlNode1).CanWriteWith(false,TFormulaNode(ParNode))) then exit;
			if (TFormulaNode(ParNode).CanWriteWith(false,TFormulaNode(vlNode1))) then exit;
			TNDCreator(PArCre).AddNodeError(ParNode,Err_Incompatible_Types,'');
		end;
		if TFormulaNode(vlNode1).IsLikeType(TRoutineType) or TFormulaNode(ParNode).IsLikeType(TRoutineTYpe) then begin
			vlType1 := vlNode1.GetOrgType;
			if (TRoutineType(vlType1).fOfObject) and not(iCompCode in [IC_Eq,IC_NotEq]) then begin
				TNDCreator(ParCre).AddNodeError(ParNode,Err_Invalid_Operation,'');
			end;
		end;
	end;
	inherited ValidateNode(ParCre,parNode);
end;

function TCompNode.CheckConvertTest(ParType1,ParType2 : TType) : boolean;
begin
	if inherited CheckConvertTest(ParType1,ParType2) then exit(true);
	if (parType1 is TClassType) or (ParType2 is TClassType) then begin
		if ParType1.CanWriteWith(false,ParType2) then exit(true);
		if ParType2.CanWriteWith(false,ParType1) then exit(true);
	end;
	exit(false);
end;


procedure TCompNode.Commonsetup;
begin
	inherited Commonsetup;
	iComplexity :=CPX_Comp;
end;

procedure TCompNode.InitParts;
begin
	SetParts(TFormulaList.Create);
end;


procedure TCompNode.ValidateAfter(ParCre : TCreator);
var
	vlNode1 : TFormulaNode;
	vlNode2 : TFormulaNode;
	vlType1 : TType;
	vlType2 : TType;
begin
	inherited ValidateAfter(ParCre);
	Get2SubNode(vlNode1,vlNode2);
	if vlNode1 = nil then exit;
	vlType1 := vlNode1.GetType;
	if vlType1 = nil then exit;
	if vlNode2 = nil then exit;
	vlType2 := vlNode2.GetType;
	if vlType2 = nil then exit;
	vlNode1.ValidateConstant(ParCre,@vlType2.ValidateConstant);
	vlNode2.ValidateConstant(ParCre,@vlType1.ValidateConstant);
end;

function TCompNode.CreatePartSec(ParCre : TSecCreator;ParSecond : boolean): boolean;
var
	vlMac  : TMacBase;
	vlMac1 : TMacBase;
	vlMac2 : TMacBase;
	vlNode1 : TFormulaNode;
	vlNode2 : TFormulaNode;
	vlPoc  : TFormulaPoc;
	vlBig  : boolean;
	vlSSize : TSIze;
begin
	vlSSize := GetAssemblerInfo.GetSystemSize;
	vlNode1 := TFormulaNode(iParts.fStart);
	if vlNode1 = nil then exit(true);
	vlNode2 := TFormulaNode(vlNode1.fNxt);
	if vlNode2= nil then exit(true);
	if vlNode1.fComplexity > vlNode2.fComplexity then begin
		vlMac1 := vlNode1.CreateMac(MCO_Result,ParCre);
		vlMac2 := vlNode2.CreateMac(MCO_Result,ParCre);
	end else begin
		vlMac2 := vlNode2.CreateMac(MCO_Result,ParCre);
		vlMac1 := vlNode1.CreateMac(MCO_Result,ParCre);
	end;
	vlBig := false;
	if vlMac1.fSize > vlSSize then begin
		vlMac1.SetSize(vlSSize);
		vlMac2.SetSize(vlSSize);
		if ParSecond then begin
			vlMac1.AddExtraOffset(vlSSize);
			vlMac2.AddExtraOffset(vlSSize);
		end;
		vlBig := true;
	end;
	vlPoc := TCompFor.Create(iCompCode);
	ParCre.AddSec(vlPoc);
	vlPoc.SetVar(1,vlMac1);
	vlPoc.SetVar(2,vlMac2);
	vlMac := vlPoc.CalcOutputMac(ParCre);
	if vlBig and not (ParSecond) then begin
		ParCre.AddSec(TCondJumpPoc.Create(false,vlMac,ParCre.fLabelFalse));
	end else begin
		ParCre.MakeJumpFromCond(vlMac);
	end;
	exit(vlBig);
end;
function TCompNode.CreateSec(ParCre:TSecCreator):boolean;
begin
    if CreatePartSec(ParCre,false) then begin
		CreatePartSec(ParCre,true);
	end;
	exit(true);
end;

function TCompNode.CreateMac(ParOpt:TMacCreateOption;ParCre:TSecCreator):TMacBase;
var vlLabelTrue  : TLabelPoc;
	vlLabelFalse : TLabelPoc ;
begin
	case ParOpt of
	MCO_Result:begin
		vlLabelTrue  := ParCre.fLabelTrue;
		vlLabelFalse := ParCre.fLabelFalse;
		ParCre.SetLabelTrue(PArCre.CreateLabel);
		ParCre.SetLabelFalse(ParCre.CreateLabel);
		CreateSec(ParCre);
		CreateMac := ParCre.ConvJumpToBool(GetTypeSize);
		ParCre.SetLabelTrue(vlLabelTrue);
		ParCre.SetLabelFalse(vlLabelFalse);
	end
	else CreateMac := inherited CreateMac(Paropt,parCre);
end;

end;

constructor TCompNode.Create(ParCode : TIdentCode;ParBooleanType:TType);
begin
	iCOmpCode := ParCode;
	inherited Create(ParBooleanType);
	iIdentCode := IC_CompNode;
end;


procedure TCOmpNode.GetOperStr(var ParOper:String);
var vlTxt:pchar;
begin
	case iCompCode of
		IC_Bigger   :vlTxt := '>';
		IC_BiggerEq :vlTxt := '>=';
		IC_Lower    :vlTxt := '<';
		IC_LowerEq  :vlTxt := '<=';
		IC_Eq       :vlTxt := '=';
		IC_NotEq    :vlTxt := '<>';
		else         vlTxt := '??';
	end;
	ParOper := strpas(vlTxt);
end;





end.
