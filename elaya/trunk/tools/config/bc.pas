{$H+}
{$I-}
uses sysutils;
var
	dir_sep :ansistring;
	path_sep:ansistring;

	cf_host   : ansistring;
	cf_target : ansistring;
	cf_dirFile: ansistring;
	cf_output : ansistring;
	cf_as_program : ansistring;
	cf_ld_program : ansistring;
	cf_config     : ansistring;
	cf_opt_fpc    : ansistring;
	cf_opt_ela    : ansistring;
	cf_dir_rtl    : ansistring;
	cf_dir_program: ansistring;
	cf_dir_config : ansistring;
	cf_install_extra: ansistring;
	cf_link_exe_to  : ansistring;

	cg_baseDir : ansistring;


function AppendToFile(var ParOutFile : text;const ParToFile : ansistring):boolean;
var
	l_File : text;
	l_line : ansistring;
begin
	assign(l_file,ParToFile);
	reset(l_file);
	if(ioresult <> 0) then begin;
		writeln('Can''''t open file "',ParToFile,'"');
		exit(true);
	end;
	writeln('add ',ParToFile);
	while not(eof(l_file)) do begin
		readln(l_file,l_line);
		writeln(l_line);
		writeln(ParOutFile,l_line);
	end;
	close(l_file);
	exit(False);
end;

procedure cutPath(var ParPath : ansistring);
var
	vlCnt : longint;
begin
	vlCnt := length(ParPAth);
	if(ParPath[vlCnt]='/') then dec(vlCnt);
	while(vlCnt > 0) and (ParPath[vlCnt] <>'/') do dec(vlCnt);
	setLength(ParPath,vlCnt);
end;

function allwaysDir(const ParPath :ansistring):ansistring;
var
	l_path :ansistring;
begin
	l_path :=parPath;
	if(length(l_path) > 0) then begin
		if(l_path[length(l_path)] <> dir_sep) then l_path := l_path + dir_sep;
	end;
	exit(l_path);
end;

function addToPath(const ParPath,ParAdd : ansistring):ansistring;
begin
	exit( allwaysDir(ParPath)+ParAdd);
end;

function getNextPath(var ParPath: ansistring;var ParPos : longint):ansistring;
var
	l_out:ansistring;
begin
	setlength(l_out,0);
	while (ParPos <= length(ParPath)) and (ParPath[ParPos] <>path_sep) do begin
		l_out := l_Out + ParPath[ParPos];
		inc(ParPos);
	end;
	inc(ParPos);
	exit(l_out);
end;



function findInPath(const ParFileName:ansistring):ansistring;
var
	l_path :ansistring;
	l_dir  : ansistring;
	l_cnt  : longint;
	l_file : ansistring;
begin
	l_path := getEnvironmentVariable('PATH');
	l_cnt  := 1;
	repeat
		l_dir := getNextPath(l_path,l_cnt);
		l_file:=AddToPath(l_dir,ParFileName);
		if(FileExists(l_file)) then exit(l_file);
	until length(l_dir) = 0;
	exit(l_dir);
end;



procedure splitParameter(const ParParameter : ansistring;var ParKey,ParValue : ansistring);
var
	l_pos : longint;
begin
	l_pos :=pos('=',ParParameter);
	if(l_pos > 0) then begin
		ParKey := copy(ParParameter,1,l_pos -1);
		ParValue := copy(ParParameter,l_pos + 1,length(ParParameter) - l_pos);
		ParKey := trim(ParKey);
		ParValue := trim(ParValue);
	end else begin
		ParValue := ParParameter;
		setLength(ParKey,0);
	end;
end;


procedure automaticSet;
begin
	setLength(cf_host,0);
	setLength(cf_target,0);
	{$ifdef WIN32}
		cf_host := 'win32';
		cf_target := 'win32';
	{$endif}
	{$ifdef LINUX}
		cf_host := 'linux';
		cf_target := 'linux';

	{$endif}
end;

procedure scanParameters;
var
	l_cnt : longint;
	l_key : ansistring;
	l_value : ansistring;
begin
	l_cnt := 1;

	while(l_cnt <=paramcount) do begin
		splitParameter(paramstr(l_cnt),l_key,l_value);
		if(l_key = 'host') then cf_host :=l_value else
		if(l_key = 'dirfile') then cf_dirFile := l_value else
		if(l_key = 'config') then cf_config := l_value  else
		if(l_key = 'output') then cf_output := l_value;
		inc(l_cnt);
	end;
end;


procedure writeMakeFiles(const ParDirFile,ParBaseDir : ansistring);
var
	l_File : text;
	l_Line : ansistring;
	l_Path : ansistring;
	l_MakeFile : ansistring;
	l_IncMake  : ansistring;
	l_Out  : text;
begin
	assign(l_File,ParDirFile);
	reset(l_File);
	if(ioresult <> 0) then begin
		writeln(stdErr,'Can''''t open ',ParDirFile);
		halt(1);
	end;
	while not(eof(l_file)) do begin
		readln(l_file,l_line);
		l_Path := addToPath(ParBaseDir,'rtl');
		l_Path := addToPath(l_Path,l_line);
		l_Makefile := addToPath(l_Path,'Makefile');
		l_IncMake  := addToPath(l_Path,'Makefile.inc');
		assign(l_Out,l_Makefile);
		rewrite(l_Out);
		if(ioresult <> 0) then begin
			writeln(stdErr,'Can''''t create ',l_Makefile);
			halt(1);
		end;
		writeln(l_Out,'# Autogenerated');
		writeln(l_Out,'#        Please don''t edit');
		writeln(l_Out,'#');
		writeln(l_Out,'root_path=',addToPath(ParBaseDir,''));
		if(fileExists(l_incMake)) then writeln(l_Out,'include Makefile.inc');
		writeln(l_Out,'include $(root_path)Makefile.ela');
		close(l_Out);
	end;
	close(l_File);
end;


function parseConfig(const p_fileName,p_target : ansistring):boolean;
var
	l_file : text;
	l_line : ansistring;
	l_found: boolean;
	l_key  : ansistring;
	l_value: ansistring;
begin

	setLength(cf_as_program,0);
	setLength(cf_ld_program,0);
	l_found := false;

	assign(l_file,p_fileName);
	reset(l_file);
	if(ioresult <> 0) then exit(true);
	while not(eof(l_file)) do begin
		readln(l_file,l_line);
		l_line := trim(l_line);
		if(length(l_line)>0) then begin
			if(l_line[1]='[') then begin
				l_found :=false;
				if((l_line = '[]') or (copy(l_line,2,length(l_line)-2) = p_target)) then l_found := true;
			end else begin
				if(l_found) then begin
					splitParameter(l_line,l_key,l_value);
					if(l_key='as_program') then cf_as_program := l_value else
					if(l_key='ld_program') then cf_ld_program := l_value else
					if(l_key = 'opt_ela') then cf_opt_ela := l_value else
					if(l_key = 'opt_fpc') then cf_opt_fpc := l_value else
					if(l_key = 'dir_rtl') then cf_dir_rtl := l_value else
					if(l_key = 'dir_program') then cf_dir_program := l_value else
					if(l_key = 'dir_config') then cf_dir_config := l_value else
					if(l_key = 'link_exe_to') then cf_link_exe_to := l_value else
					if(l_key = 'install_extra') then cf_install_extra := l_value else begin
						writeln(stdErr,'invalid key=',l_key,' value=',l_value);
					end;
				end;
			end;
		end;
	end;
	close(l_file);
	exit(false);
end;

function createDirIfNotExists(const ParDirName : ansistring):boolean;
begin
	if(not fileExists(ParDirName)) then begin
		if not(createDir(ParDirName)) then begin
			writeln('Error: Createing directory "',ParDirName,'" failed');
			exit(true);
		end;
	end;
	exit(false);
end;


procedure makeBuildConfig(p_target : ansistring);
var
	l_outputFile     : text;
	l_outputFileName : ansistring;
	l_ld_path        : ansistring;
	l_as_path        : ansistring;
	l_baseDir        : ansistring;
begin
	cf_target := p_target;

	if(length(cf_config)  <> 0) then begin
		if(parseConfig(cf_config+'.'+cf_host,p_target)) then begin
			writeln(stdErr,'Parsing config failed');
			halt(1);
		end;
	end;

	if((cf_target <> 'linux') and (cf_target <> 'win32')) then begin
		writeln(stderr,'error: wrong target platform');
		halt(1);
	end;

	if(cf_as_program = '') then begin
		writeln(stdErr,'error: no entry for "as" program');
		halt(1);
	end;

	if(cf_ld_program = '') then begin
		writeln(stdErr,'error: no entry for "ld" program');
		halt(1);
	end;

	l_as_path := findInPath(cf_as_program);
	if(l_as_path = '') then begin
		writeln(stdErr,'Assembler "',cf_as_program,'" not found');
		halt(1);
	end;

	l_ld_path := findInPath(cf_ld_program);
	if(l_ld_path = '') then begin
		writeln(stdErr,'Linker "',cf_ld_program,'" not found');
		halt(1);
	end;

	l_outputFileName := addToPath(cf_output,'build_conf.'+cf_host+'.'+cf_target);
	assign(l_outputFile,l_outputFileName);
	rewrite(l_outputFile);
	if(ioresult <> 0) then begin
		writeln(stdErr,'Error: Can''''t open output file:',l_outputFileName);
		halt(1);
	end;

	l_baseDir := cg_baseDir;



	writeln(l_outputFile,'Dir_ld=',l_ld_path);
	writeln(l_outputFile,'Dir_as=',l_as_path);
	writeln(l_outputFile,'Dir_Dirt=',AddToPath('.','bin'));
	writeln(l_outputFile,'Os_Host=',cf_host);
	writeln(l_outputFile,'Os_Target=',cf_target);
	writeln(l_outputFile,'Cpl_Target=',cf_host);
	writeln(l_outputFile,'Dir_Cpl_Lib=',allwaysDir(addToPath(addToPath(cf_dir_rtl,'extra'),'lib')));
	writeln(l_outputFile,'Dir_Rtl=',allwaysDir(addToPath(addToPath(cf_dir_rtl,'lib'),cf_target)));
	writeln(l_outputFile,'Dir_Program=',allwaysDir(addToPath(cf_dir_rtl,'bin')));
	writeln(l_outputFile,'Fpc=fpc');
	writeln(l_outputFile,'Ela=ela');
	writeln(l_outputfile,'eladep=eladep');
	writeln(l_outputFile,'Can_Cross_Compile=y');
	if(cf_host='win32') then begin
		writeln(l_outputFile,'cmd_rm=del');
		writeln(l_outputFile,'cmd_cp=copy');
		writeln(l_outputFile,'pp_unit_ext=.ppw');
		writeln(l_outputFile,'exe_ext=.exe');
	end else if (cf_host='linux') then begin
		writeln(l_outputFile,'cmd_rm=rm');
		writeln(l_outputFile,'cmd_cp=copy');
		writeln(l_outputFile,'pp_unit_ext=.ppu');
		writeln(l_outputFile,'exe_ext=');
	end;
	writeln(l_outputFile,'Opt_Fpc=',cf_opt_fpc);
	writeln(l_outputFile,'Opt_Ela=',cf_opt_ela);
	writeln(l_outputFile,'link_exe_to=',cf_link_exe_to);
	writeln(l_outputFile,'install_exta=',cf_install_extra);
	close(l_outputFile);
end;


var

	l_outputFileName : ansistring;
	l_outputFile     : text;
begin
	cf_dirFile := '';

	automaticSet;
	scanParameters;

	if(cf_host='linux') then begin
		dir_sep := '/';
		path_sep := ':';
	end else if(cf_host='win32') then begin
		dir_sep := '\';
		path_sep := ';';
	end else begin
		writeln(stdErr,'error: wrong host platform');
		halt(1);
	end;

	if(cf_output='') then begin
		writeln(stdErr,'Error:No output file specified');
		halt(1);
	end;

	cg_baseDir := getCurrentDir;
	if(length(cf_dirFile) <> 0) then writeMakeFiles(cf_dirFile,cg_BaseDir);
	parseConfig(cf_config+'.'+cf_host,'');
	l_outputFileName := addToPAth(cf_output,'build_conf.gen');
	assign(l_outputFile,l_outputFileName);
	rewrite(l_outputFile);
	if(ioresult <> 0) then begin
		writeln(stdErr,'Error: can''''t open output file:',l_outputFileName);
		halt(1);
	end;
	writeln(l_outputFile,'os_host=',cf_host);
	writeln(l_outputFile,'Dir_Ela_Rtl_Base=',allwaysDir(addToPath(cf_dir_rtl,'lib')));
	writeln(l_outputFile,'Rtl_Build_Out=',allwaysDir(AddToPath(AddToPath(cg_BaseDir,'rtl'),'bin')));
	writeln(l_outputFile,'Dir_Cfg=',allwaysDir(cf_dir_config));
	close(l_outputFile);



	makeBuildConfig('linux');
	makeBuildConfig('win32');



end.